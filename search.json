[{"title":"代理模式 - proxy","url":"https://Xmtd.github.io/2020/02/24/proxy/","content":"<h3 id=\"什么是代理模式\"><a href=\"#什么是代理模式\" class=\"headerlink\" title=\"什么是代理模式\"></a>什么是代理模式</h3><blockquote>\n<p>代理模式（英语：Proxy Pattern）是程序设计中的一种设计模式。</p>\n</blockquote>\n<blockquote>\n<p>所谓的代理者是指一个类别可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、内存中的大对象、文件或其它昂贵或无法复制的资源。</p>\n</blockquote>\n<blockquote>\n<p>著名的代理模式例子为引用计数（英语：reference counting）指针对象。</p>\n</blockquote>\n<blockquote>\n<p>当一个复杂对象的多份副本须存在时，代理模式可以结合享元模式以减少内存用量。典型作法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除。</p>\n</blockquote>\n<p>上面是维基百科中对代理模式的一个整体的定义.而在JavaScript中代理模式的具体表现形式就是ES6中的新增对象 — <em><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\" rel=\"noopener\">Proxy</a></em></p>\n<h3 id=\"Proxy-介绍\"><a href=\"#Proxy-介绍\" class=\"headerlink\" title=\"Proxy 介绍\"></a>Proxy 介绍</h3><p>在MDN上对于Proxy的解释是:</p>\n<blockquote>\n<p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p>\n</blockquote>\n<p><code>Proxy</code>用于修改某些操作的默认行为，也可以理解为在目标对象之前架设一层拦截，外部所有的访问都必须先通过这层拦截，因此提供了一种机制，可以对外部的访问进行过滤和修改。这个词的原理为代理，在这里可以表示由它来“代理”某些操作，译为“代理器”</p>\n<p><em><a href=\"https://www.w3cplus.com/javascript/use-cases-for-es6-proxies.html\" target=\"_blank\" rel=\"noopener\">Proxy的使用场景</a></em></p>\n<p>ES6原生提供了Proxy构造函数，用来生成Proxy实例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>\n\n<p><code>Proxy</code>对象的所有用法，都是上面的这种形式。不同的只是<code>handle</code>参数的写法。其中<code>new Proxy</code>用来生成<code>Proxy</code>实例，<code>target</code>是表示所要拦截的对象，<code>handle是</code>用来定制拦截行为的对象</p>\n<p>下面是简单的Proxy例子，使用的是get代理</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = &#123;</span><br><span class=\"line\">  x: <span class=\"number\">10</span>,</span><br><span class=\"line\">  y: <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: (obj, prop) =&gt; 42</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">target = new Proxy(target, handler)</span><br><span class=\"line\"></span><br><span class=\"line\">target.x //42</span><br><span class=\"line\">target.y //42</span><br><span class=\"line\">target.x // 42</span><br></pre></td></tr></table></figure>\n\n<p>结果是一个对象将为任何属性访问操作都返回“42”。 这包括<code>target.x</code>，<code>target[&#39;x&#39;]</code>，<code>Reflect.get(target, &#39;x&#39;)</code>等。<br>但是，Proxy 当然不限于属性的读取。 它只是十几个不同代理中的一个：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handler.getPrototypeOf()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span></span><br><span class=\"line\"></span><br><span class=\"line\">handler.setPrototypeOf()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span></span><br><span class=\"line\"></span><br><span class=\"line\">handler.isExtensible()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span></span><br><span class=\"line\"></span><br><span class=\"line\">handler.preventExtensions()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span></span><br><span class=\"line\"></span><br><span class=\"line\">handler.getOwnPropertyDescriptor()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, \"foo\") 时。</span></span><br><span class=\"line\"></span><br><span class=\"line\">handler.defineProperty()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, \"foo\", &#123;&#125;) 时。</span></span><br><span class=\"line\"></span><br><span class=\"line\">handler.has()  <span class=\"comment\">// 以下几个是常用的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 \"foo\" in proxy 时。</span></span><br><span class=\"line\"></span><br><span class=\"line\">handler.get()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span></span><br><span class=\"line\"></span><br><span class=\"line\">handler.set()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span></span><br><span class=\"line\"></span><br><span class=\"line\">handler.deleteProperty()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</span></span><br><span class=\"line\"></span><br><span class=\"line\">handler.ownKeys()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</span></span><br><span class=\"line\"></span><br><span class=\"line\">handler.apply()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。</span></span><br><span class=\"line\"></span><br><span class=\"line\">handler.construct()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"具有代理的API-复杂的示例\"><a href=\"#具有代理的API-复杂的示例\" class=\"headerlink\" title=\"具有代理的API - 复杂的示例\"></a>具有代理的API - 复杂的示例</h3><p>通过使用简单用例中的知识，我们可以创建一个API包装器，以便在我们的应用程序中使用。 当前只支持 get 和 post 请求，但它可以很容易地扩展。代码如下所示。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> api  = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>(target, key, context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target[key]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> target[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'get'</span>, <span class=\"string\">'post'</span>].reduce(<span class=\"function\">(<span class=\"params\">acc, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      acc[key] = <span class=\"function\">(<span class=\"params\">config, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!config || !config.url || config.url === <span class=\"string\">''</span>) &#123; <span class=\"comment\">// 没有URL</span></span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Url cannot be empty.'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> isPost = key === <span class=\"string\">'post'</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isPost &amp;&amp; !data) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Please provide data in JSON format when using POST request.'</span>); <span class=\"comment\">// post请求提供JSON格式的数据</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        config.headers = isPost ? <span class=\"built_in\">Object</span>.assign(config.headers || &#123;&#125;, &#123; <span class=\"string\">'content-type'</span>: <span class=\"string\">'application/json;chartset=utf8'</span> &#125;) : config.headers;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">          xhr.open(key, config.url);</span><br><span class=\"line\">          </span><br><span class=\"line\">          <span class=\"keyword\">if</span> (config.headers) &#123;</span><br><span class=\"line\">              <span class=\"built_in\">Object</span>.keys(config.headers).forEach(<span class=\"function\">(<span class=\"params\">header</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                  xhr.setRequestHeader(header, config.headers[header]);</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">          xhr.onload = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (xhr.status === <span class=\"number\">200</span> ? resolve : reject)(xhr);</span><br><span class=\"line\">          xhr.onerror = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(xhr);</span><br><span class=\"line\">          xhr.send(isPost ? <span class=\"built_in\">JSON</span>.stringify(data) : <span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, target)[key]</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>() &#123; <span class=\"comment\">// 无法为代理对象新增属性</span></span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'API methods are readonly'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  deleteProperty() &#123; <span class=\"comment\">// 禁止删除属性</span></span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'API methods cannot be deleted!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 使用</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  api.get(&#123;</span><br><span class=\"line\">      url: <span class=\"string\">'my-url'</span></span><br><span class=\"line\">  &#125;).then(<span class=\"function\">(<span class=\"params\">xhr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\">  &#125;, (xhr) =&gt; &#123;</span><br><span class=\"line\">      alert(<span class=\"string\">'Fail'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>get</code> 在这里很有趣，它做了几件事。<code>target</code> 是一个空对象，<code>get</code> 方法将在第一次有人使用 api 时创建所有方法(如当前的 get 和 post请求)，在 reduce 回调中，我们根据提供的配置执行API规范所需的验证和检查。在此示例中，我们不允许空URL和发布请求而不提供数据。这些检查可以扩展和修改，但重要的是我们只能在这一个地方集中处理。<br><code>reduce</code> 仅在第一次API调用时完成，之后都会跳过整个 reduce 进程，get 只会执行默认行为并返回属性值，即API处理程序。每个处理程序返回一个Promise对象，负责创建请求并调用服务</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>当您需要对数据进行更多控制时，代理可以派上用场。你可以根据受控规则扩展或拒绝对原始数据的访问，从而监视对象并确保正确行为。</p>\n","categories":[],"tags":["es6"]},{"title":"简单易懂的CSS Modules","url":"https://Xmtd.github.io/2019/11/27/cssmodule/","content":"<h3 id=\"CSS的痛点\"><a href=\"#CSS的痛点\" class=\"headerlink\" title=\"CSS的痛点\"></a>CSS的痛点</h3><p>我们都知道，css入门简单，深入就比较难，样式简单维护难，css痛点有很多</p>\n<ol>\n<li><p>css的规则是全局的，任何一个组件的样式规则，都对真个页面有效，很容易出现全局污染（覆盖）问题</p>\n</li>\n<li><p>为了解决全局污染问题，那就吧class命名写长一点、加一层父级选择器、降低冲突几率，但css命名就混乱了</p>\n</li>\n<li><p>组件依赖管理不彻底，组件应该相互独立，引入一个组件时，应该只引入它所需要的 CSS 样式</p>\n</li>\n</ol>\n<h3 id=\"CSS-Module\"><a href=\"#CSS-Module\" class=\"headerlink\" title=\"CSS Module\"></a>CSS Module</h3><p>为了解决一上问题，就产生css module, css module会产生局部作用域，它会产生一个独一无二的<code>class</code>名字，不会与其他同名选择器重名</p>\n<h4 id=\"启用-css-module\"><a href=\"#启用-css-module\" class=\"headerlink\" title=\"启用 css module\"></a>启用 css module</h4><p>在项目里应用CSS Modules有很多方法，目前比较常用的是使用webpack的<a href=\"https://github.com/webpack-contrib/css-loader#css-modules\" target=\"_blank\" rel=\"noopener\">css-loader</a>,此处是与sass一起使用的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.scss/</span>,</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                loader: <span class=\"string\">'style-loader'</span></span><br><span class=\"line\">            &#125;, &#123;</span><br><span class=\"line\">                loader: <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">                options: &#123;</span><br><span class=\"line\">                    modules: <span class=\"literal\">true</span>,   <span class=\"comment\">// 开启 css module</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, &#123;</span><br><span class=\"line\">                loader: <span class=\"string\">'postcss-loader'</span>    <span class=\"comment\">// 自动添加css前缀</span></span><br><span class=\"line\">            &#125;, &#123;</span><br><span class=\"line\">                loader: <span class=\"string\">'sass-loader'</span>,</span><br><span class=\"line\">                options: &#123;</span><br><span class=\"line\">                    sourceMap: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    outputStyle: &#123;</span><br><span class=\"line\">                        expanded: <span class=\"literal\">true</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用css-module\"><a href=\"#使用css-module\" class=\"headerlink\" title=\"使用css module\"></a>使用css module</h4><p>编写 scss</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.root</span> &#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.text</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> styles <span class=\"keyword\">from</span> <span class=\"string\">'./index.scss'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div className=&#123;styles.root&#125;&gt;</span><br><span class=\"line\">    &lt;div className=&#123;styles.text&#125;&gt;test&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>\n<p>编译之后<br><img src=\"/images/WechatIMG939.png\" alt=\"avatar\"><br>可以看出css module为每个class生成了唯一的class类名，它将class转换成对应的全局唯一hash值来形成<code>局部作用域</code>。<br>css module默认使用的是<code>局部作用域</code>，就相当于给每个 class 名外加了一个 :local 这是默认的，也可以显式使用，<br>但是当需要修改第三方组件的class时，就需要使用<code>全局作用域</code>来更改类</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:local(.root) &#123;     // 默认是局部作用域</span><br><span class=\"line\">  :local(.text)&#123;</span><br><span class=\"line\">    width: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  :global &#123;     // 修改第三方组件（antd）,使用全局作用域，但是他是相对于.root底下的全局作用域，所已完全不必担心污染其他组件</span><br><span class=\"line\">    .ant-btn &#123;</span><br><span class=\"line\">      width: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-class\">.ant-input</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/WechatIMG967.png\" alt=\"avatar\"><br>图上所知，加上global属性，就会在相对应的root底下的<code>全局作用域</code>找类名，那么他们在元素上用法的区别就是局部作用域需要使用js式（styls.xxx）;全局作用域的就是直接使用</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.root &#123;</span><br><span class=\"line\">    .text &#123;</span><br><span class=\"line\">        width: <span class=\"number\">200</span>px</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    :global &#123;</span><br><span class=\"line\">        .text2 &#123;</span><br><span class=\"line\">             width: <span class=\"number\">200</span>px</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> styles <span class=\"keyword\">from</span> <span class=\"string\">'./index.scss'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div className=&#123;styles.root&#125;&gt;</span><br><span class=\"line\">    &lt;div className=&#123;styles.text&#125;&gt;test&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;div className='text2'&gt;test2&lt;/</span>div&gt;  <span class=\"comment\">// 直接使用</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><p><em><a href=\"https://vue-loader.vuejs.org/zh/guide/css-modules.html#%E7%94%A8%E6%B3%95\" target=\"_blank\" rel=\"noopener\">vue中使用css module</a></em></p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>无论是一直以来我们认真遵循的命名约定，还是这个新的CSS Modules，目的都是一样的：可维护的css代码。我觉得就CSS Modules基本还是在写css这一点来说，它还是很友好的。</p>\n","categories":[],"tags":["css","css-modules"]},{"title":"http server","url":"https://Xmtd.github.io/2019/11/25/http-server/","content":"<h3 id=\"使用http-server快速搭建本地服务\"><a href=\"#使用http-server快速搭建本地服务\" class=\"headerlink\" title=\"使用http-server快速搭建本地服务\"></a>使用http-server快速搭建本地服务</h3><p><em>在静态页面中需要进行局域网进行访问时，可以开启这个 http-server 来进行访问</em></p>\n<ul>\n<li><p>该环境是基于node环境的，所以必须先安装node.js</p>\n<blockquote>\n<p>打开命令行模式，输入<code>node -v</code><br>如果显示了版本号，就说明已经安装完成。如果提示没有这个命令，请在<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">node.js官网</a>进行安装</p>\n</blockquote>\n</li>\n<li><p>如果完成上一步，在命令行下进行安装http-server,命令是<code>npm install http-server -g</code></p>\n</li>\n<li><p>安装完成后，进入你需要局域网访问的目录，敲<code>hs</code>命令就会显示访问的端口，就可以直接进行访问</p>\n</li>\n</ul>\n<p><img src=\"/images/http-server.png\" alt=\"avatar\"></p>\n","categories":[],"tags":["server"]},{"title":"async/await 用法整理","url":"https://Xmtd.github.io/2019/11/18/async-await/","content":"<p>它最受欢迎的地方：<strong>能让异步代码写起来像同步代码，并且方便控制顺序。</strong></p>\n<h3 id=\"async-await-概念解释\"><a href=\"#async-await-概念解释\" class=\"headerlink\" title=\"async/await 概念解释\"></a>async/await 概念解释</h3><ul>\n<li><p>async</p>\n<blockquote>\n<p>async的用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行，async 函数返回的是一个promise 对象。</p>\n</blockquote>\n</li>\n<li><p>await</p>\n<blockquote>\n<p>await的含义为等待。意思就是代码需要等待await后面的函数运行完并且有了返回结果之后，才继续执行下面的代码。这正是同步的效果。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"async函数是Generator函数的语法糖，并对Generator函数进行了改进。\"><a href=\"#async函数是Generator函数的语法糖，并对Generator函数进行了改进。\" class=\"headerlink\" title=\"async函数是Generator函数的语法糖，并对Generator函数进行了改进。\"></a>async函数是Generator函数的语法糖，并对Generator函数进行了改进。</h3><h4 id=\"Generator函数\"><a href=\"#Generator函数\" class=\"headerlink\" title=\"Generator函数\"></a>Generator函数</h4><h5 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><em>简介</em></h5><ul>\n<li>Generator 函数是一个状态机，封装了多个内部状态。执行Generator函数会返回一个<a href=\"http://es6.ruanyifeng.com/#docs/iterator\" target=\"_blank\" rel=\"noopener\">遍历器对象</a>，可以依次遍历Generator函数的每一个状态，<br>但是只有调用<code>next</code>方法才能遍历到下一个状态，所以其实提供了一种暂停执行函数，<code>yield</code>表达式就是暂停标志。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">helloWorldGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'ending'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> hw = helloWorldGenerator();</span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()<span class=\"comment\">// &#123; value: 'hello', done: false &#125;</span></span><br><span class=\"line\">hw.next()<span class=\"comment\">// &#123; value: 'world', done: false &#125;</span></span><br><span class=\"line\">hw.next()<span class=\"comment\">// &#123; value: 'ending', done: true &#125;</span></span><br><span class=\"line\">hw.next()<span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看出，helloWorldGenerator函数被调用时并没有执行，而是返回了一个遍历器对象，只有调用<code>next</code>方法、内部指针指向该语句时才执行，每次调用next方法，就回返回一个对象包含<code>value</code>和<br><code>done</code>两个属性，<code>value</code>属性表示内部状态的值，是yield表达式后面表达式返回的值；<code>done</code>属性是个布尔值，表示是否遍历结束。即实现了<code>函数可以暂停，也可恢复执行</code></p>\n<h5 id=\"Generator暂停恢复执行原理\"><a href=\"#Generator暂停恢复执行原理\" class=\"headerlink\" title=\"Generator暂停恢复执行原理\"></a><em>Generator暂停恢复执行原理</em></h5><p>要懂得原理，得了解协程的概念</p>\n<blockquote>\n<p>一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），<br>等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>\n</blockquote>\n<p>协程是一种比线程更加轻量级的存在。普通线程是抢先式的，会争夺cpu资源，而协程是合作的，可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。它的运行流程大致如下：</p>\n<ol>\n<li>协程A开始执行</li>\n<li>协程A执行到某个阶段，进入暂停，执行权转移到协程B</li>\n<li>协程B执行完成或暂停，将执行权交还A</li>\n<li>协程A恢复执行</li>\n</ol>\n<p>协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>\n<h5 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a><em>执行器</em></h5><p>通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器,<code>co</code> 模块就是一个著名的执行器。</p>\n<p>Generator 是一个异步操作的容器。它是需要手动执行的，它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。两种方法可以做到这一点：</p>\n<pre><code>1. 回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。\n2. Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权</code></pre><p>一个基于 Promise 对象的简单自动执行器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">gen</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> g = gen();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = g.next(data);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result.done) <span class=\"keyword\">return</span> result.value;</span><br><span class=\"line\">    result.value.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      next(data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  next()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">使用：</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> response1 = <span class=\"keyword\">yield</span> fetch(<span class=\"string\">'https://xxx'</span>) <span class=\"comment\">//返回promise对象</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'response1'</span>)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(response1)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> response2 = <span class=\"keyword\">yield</span> fetch(<span class=\"string\">'https://xxx'</span>) <span class=\"comment\">//返回promise对象</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'response2'</span>)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(response2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">run(foo);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，只要 Generator 函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p>\n<h5 id=\"async的改进\"><a href=\"#async的改进\" class=\"headerlink\" title=\"async的改进\"></a><em>async的改进</em></h5><p>async彻底告别了执行器和生成器，实现更加直观简洁的代码，async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。可以说async 是Generator函数的语法糖，并对Generator函数进行了改进。</p>\n<p>async函数对 Generator 函数的改进，体现在以下四点：</p>\n<pre><code>1. 内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。\n2. 更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果\n3. 更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。\n4. 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用</code></pre><h3 id=\"async-await-与-promise-相比的优势\"><a href=\"#async-await-与-promise-相比的优势\" class=\"headerlink\" title=\"async/await 与 promise 相比的优势\"></a>async/await 与 promise 相比的优势</h3><ol>\n<li><p><strong>同步代码编写方式</strong>:</p>\n<ul>\n<li>用同步的思维来解决异步问题的方案。</li>\n<li>Promise使用then函数进行链式调用，一直点点点，是一种从左向右的横向写法；</li>\n<li>async/await从上到下，顺序执行，就像写同步代码一样，更符合代码编写习惯。</li>\n</ul>\n</li>\n<li><p><strong>多个参数传递</strong>:</p>\n<ul>\n<li>Promise的then函数只能传递一个参数，虽然可以通过包装成对象来传递多个参数，但是会导致传递冗余信息，比较麻烦；</li>\n<li>async/await没有这个限制，可以当做普通的局部变量来处理，用let或者const定义的块级变量想怎么用就怎么用，完全没有限制；</li>\n</ul>\n</li>\n<li><p><strong>同步代码和异步代码可以一起编写</strong>:</p>\n<ul>\n<li>使用Promise的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰；</li>\n<li>async/await整个书写习惯都是同步的，不需要纠结同步和异步的区别，当然，异步过程需要包装成一个Promise对象放在await关键字后面；</li>\n</ul>\n</li>\n<li><p><strong>基于协程</strong>:</p>\n<ul>\n<li>Promise是根据函数式编程的范式，对异步过程进行了一层封装；</li>\n<li>async/await基于协程的机制，是真正的“保存上下文，控制权切换……控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述；</li>\n</ul>\n</li>\n<li><p>✨<strong>这点并不是优势也不算劣势（只能串行）</strong>:<br> 它不能取代 Promise，尤其是我们可以很方便地用Promise.all()来实现并发，而async/await只能实现串行。</p>\n</li>\n</ol>\n<h3 id=\"async关键字\"><a href=\"#async关键字\" class=\"headerlink\" title=\"async关键字\"></a>async关键字</h3><blockquote>\n<p>async函数执行和普通函数一样，函数名带个()就可以了，参数个数随意，没有限制，也需要有async关键字；只是返回值是一个Promise对象，可以用then函数得到返回值，用catch抓整个流程中发生的错误；</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testAsync</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"hello async\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = testAsync(); <span class=\"comment\">// 返回一个Promise对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\"><span class=\"comment\">// async函数返回的是一个Promise对象，async函数（包括函数语句、函数表达式、Lambda表</span></span><br><span class=\"line\"><span class=\"comment\">// 达式）会返回一个Promise对象，如果在函数中return一个直接量，async会把这个直接量通</span></span><br><span class=\"line\"><span class=\"comment\">// 过Promise.resolve() 封装成 Promise 对象；</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// async函数返回的是一个Promise对象，所以在最外层不能用await获取其返回值的情况，</span></span><br><span class=\"line\"><span class=\"comment\">// 应该使用原始的方式：then()链来处理这个Promise对象</span></span><br><span class=\"line\">testAsync().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(v);    <span class=\"comment\">// 输出 hello async</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><strong>表明程序里面可能有异步过程：</strong></p>\n<ul>\n<li>async关键字表明程序里面可能有异步过程，里面可以有await关键字；</li>\n<li>当然全部是同步代码也没关系，但是这样async关键字就显得多余了；</li>\n</ul>\n</li>\n<li><p><strong>非阻塞，无等待：</strong></p>\n<ul>\n<li>async函数里面如果有异步过程会等待，但是<code>async函数本身会马上返回</code>，不会阻塞当前线程;</li>\n<li>可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染，async函数内部由await关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回；</li>\n<li>在没有await的情况下执行async函数，它会立即执行，返回一个Promise对象，并且绝对不会阻塞后面的语句，这和普通返回Promise对象的函数并无二致；</li>\n</ul>\n</li>\n<li><p><strong>async函数返回类型为Promise对象：</strong><br> 这是和普通函数本质上不同的地方，也是使用时重点注意的地方；</p>\n<ul>\n<li>（1）return newPromise()；这个符合async函数本意；</li>\n<li>（2）return data；这个是同步函数的写法，这里是要特别注意的，这个时候，其实就相当于Promise.resolve(data)；还是一个Promise对象，但是在调用async函数的地方通过简单的=是拿不到这个data的，因为返回值是一个Promise对象，所以需要用.then(data =&gt; { })函数才可以拿到这个data；</li>\n<li>（3）如果没有返回值，相当于返回了Promise.resolve(undefined)；</li>\n</ul>\n</li>\n<li><p><strong>async统一catch，await不处理异步error：</strong><br> async函数返回的这个Promise对象的catch函数负责统一抓取内部所有异步过程的错误，await是不管异步过程的reject(error)消息的；</p>\n</li>\n</ol>\n<h3 id=\"await关键字\"><a href=\"#await关键字\" class=\"headerlink\" title=\"await关键字\"></a>await关键字</h3><ol>\n<li><p><strong>await只能在async函数内部使用：</strong><br> 不能放在普通函数里面，否则会报错；</p>\n</li>\n<li><p><strong>await后面也可以跟同步代码：</strong><br> 不过系统会自动将其转化成一个Promsie对象，比如：</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">await</span> <span class=\"string\">'hello world'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 相当于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 跟同步代码是一样的，还不如省事点，直接去掉await关键字</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"string\">'hello world'</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p>✨<strong>await对于失败消息的处理：</strong><br> await只关心异步过程成功的消息resolve(data)，拿到相应的数据data，至于失败消息reject(error)，不关心不处理；对于错误的处理有以下几种方法供选择：</p>\n<ol>\n<li>让await后面的Promise对象自己catch；</li>\n<li>也可以让外面的async函数返回的Promise对象统一catch；</li>\n<li>像同步代码一样，放在一个try…catch结构中；<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是React Native的回调函数，加个async关键字，没有任何影响，但是可以用await关键字</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将异步和同步的代码放在一个try..catch中，异常都能抓到</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> array = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = <span class=\"keyword\">await</span> asyncFunction();  <span class=\"comment\">// 这里用await关键字，就能拿到结果值；否则，没有await的话，只能拿到Promise对象</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.length &gt; <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// 这里会抛出异常，下面的catch也能抓到</span></span><br><span class=\"line\">            array.push(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        alert(<span class=\"built_in\">JSON</span>.stringify(error))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"使用方式实践\"><a href=\"#使用方式实践\" class=\"headerlink\" title=\"使用方式实践\"></a>使用方式实践</h3><h4 id=\"（1）像写同步代码那样，定义异步流程\"><a href=\"#（1）像写同步代码那样，定义异步流程\" class=\"headerlink\" title=\"（1）像写同步代码那样，定义异步流程\"></a>（1）像写同步代码那样，定义异步流程</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步过程封装</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">'sleep for '</span> + ms + <span class=\"string\">' ms'</span>);</span><br><span class=\"line\">        &#125;, ms);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义异步流程，就像写同步代码那样</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">'asyncFunction total executing:'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sleep1 = <span class=\"keyword\">await</span> sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'sleep1: '</span> + sleep1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [sleep2, sleep3, sleep4]= <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([sleep(<span class=\"number\">2000</span>), sleep(<span class=\"number\">1000</span>), sleep(<span class=\"number\">1500</span>)]);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'sleep2: '</span> + sleep2);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'sleep3: '</span> + sleep3);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'sleep4: '</span> + sleep4);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sleepRace = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.race([sleep(<span class=\"number\">3000</span>), sleep(<span class=\"number\">1000</span>), sleep(<span class=\"number\">1000</span>)]);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'sleep race: '</span> + sleepRace);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'asyncFunction total executing:'</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'asyncFunction done.'</span>  <span class=\"comment\">// 这个可以不返回，这里只是做个标记，为了显示流程</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 像普通函数调用async函数，在then函数中获取整个流程的返回信息，</span></span><br><span class=\"line\"><span class=\"comment\">// 在catch函数统一处理出错信息</span></span><br><span class=\"line\">asyncFunction().then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// asyncFunction return 的内容在这里获取: 'asyncFunction done.'</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// asyncFunction 的错误统一在这里抓取</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个代表asyncFunction函数后的代码，</span></span><br><span class=\"line\"><span class=\"comment\">// 显示asyncFunction本身会立即返回，不会阻塞主线程</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'after asyncFunction code executing....'</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行结果</span></span><br><span class=\"line\">after asyncFunction code executing....</span><br><span class=\"line\">sleep1: sleep <span class=\"keyword\">for</span> <span class=\"number\">2000</span> ms</span><br><span class=\"line\">sleep2: sleep <span class=\"keyword\">for</span> <span class=\"number\">2000</span> ms</span><br><span class=\"line\">sleep3: sleep <span class=\"keyword\">for</span> <span class=\"number\">1000</span> ms</span><br><span class=\"line\">sleep4: sleep <span class=\"keyword\">for</span> <span class=\"number\">1500</span> ms</span><br><span class=\"line\">sleep race: sleep <span class=\"keyword\">for</span> <span class=\"number\">1000</span> ms</span><br><span class=\"line\">asyncFunction total executing:: <span class=\"number\">5006.276123046875</span>ms</span><br><span class=\"line\">asyncFunction done.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// console输出：</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class=\"line\">    __proto__: <span class=\"built_in\">Promise</span></span><br><span class=\"line\">    [[PromiseStatus]]: <span class=\"string\">\"resolved\"</span></span><br><span class=\"line\">    [[PromiseValue]]: <span class=\"string\">\"asyncFunction done.\"</span></span><br><span class=\"line\">VM12229:<span class=\"number\">5</span> sleep1: sleep <span class=\"keyword\">for</span> <span class=\"number\">2000</span> ms</span><br><span class=\"line\">VM12229:<span class=\"number\">7</span> sleep2: sleep <span class=\"keyword\">for</span> <span class=\"number\">2000</span> ms</span><br><span class=\"line\">VM12229:<span class=\"number\">8</span> sleep3: sleep <span class=\"keyword\">for</span> <span class=\"number\">1000</span> ms</span><br><span class=\"line\">VM12229:<span class=\"number\">9</span> sleep4: sleep <span class=\"keyword\">for</span> <span class=\"number\">1500</span> ms</span><br><span class=\"line\">VM12229:<span class=\"number\">11</span> sleep race: sleep <span class=\"keyword\">for</span> <span class=\"number\">1000</span> ms</span><br><span class=\"line\">VM12229:<span class=\"number\">12</span> asyncFunction total executing:: <span class=\"number\">5004.796875</span>ms</span><br></pre></td></tr></table></figure>\n<p>代码分析：</p>\n<ul>\n<li>after asyncFunction code executing….代码位置在async函数asyncFunction()调用之后，反而先输出，这说明async函数asyncFunction()调用之后会马上返回，不会阻塞主线程；</li>\n<li>sleep1: sleep for 2000 ms这是第一个await之后的第一个异步过程，最先执行，也最先完成，说明后面的代码，不论是同步和异步，都在等他执行完毕；</li>\n<li>sleep2 ~ sleep4这是第二个await之后的Promise.all()异步过程，这是“比慢模式”，三个sleep都完成后，再运行下面的代码，耗时最长的是2000ms；</li>\n<li>sleep race: sleep for 1000 ms这是第三个await之后的Promise.race()异步过程，这是“比快模式”，耗时最短sleep都完成后，就运行下面的代码，耗时最短的是1000ms；</li>\n<li>asyncFunction total executing:: 5006.276123046875ms这是最后的统计总共运行时间代码，三个await之后的异步过程之和：<blockquote>\n<p>1000（独立的） + 2000（Promise.all） + 1000（Promise.race） = 5000ms</p>\n</blockquote>\n</li>\n<li>这个和统计出来的5006.276123046875ms非常接近，说明上面的异步过程，和同步代码执行过程一致，协程真的是在等待异步过程执行完毕；</li>\n<li>asyncFunction done.这个是async函数返回的信息，在执行时的then函数中获得，说明整个流程完毕之后参数传递的过程；</li>\n</ul>\n<h4 id=\"（2）顺序执行，结果作为下一次输入\"><a href=\"#（2）顺序执行，结果作为下一次输入\" class=\"headerlink\" title=\"（2）顺序执行，结果作为下一次输入\"></a>（2）顺序执行，结果作为下一次输入</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span></span><br><span class=\"line\"><span class=\"comment\"> * 执行的结果是 n + 200，这个值将用于下一步骤</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">takeLongTime</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(n + <span class=\"number\">200</span>), n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Promise方式调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    step1(time1)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> step2(time2))</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> step3(time3))</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// c:\\var\\test&gt;node --harmony_async_await .</span></span><br><span class=\"line\"><span class=\"comment\">// step1 with 300</span></span><br><span class=\"line\"><span class=\"comment\">// step2 with 500</span></span><br><span class=\"line\"><span class=\"comment\">// step3 with 700</span></span><br><span class=\"line\"><span class=\"comment\">// result is 900</span></span><br><span class=\"line\"><span class=\"comment\">// doIt: 1507.251ms</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// async/await方式调用</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time2 = <span class=\"keyword\">await</span> step1(time1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time3 = <span class=\"keyword\">await</span> step2(time2);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> step3(time3);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）中间参数需要保留\"><a href=\"#（3）中间参数需要保留\" class=\"headerlink\" title=\"（3）中间参数需要保留\"></a>（3）中间参数需要保留</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span></span><br><span class=\"line\"><span class=\"comment\"> * 执行的结果是 n + 200，这个值将用于下一步骤</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">takeLongTime</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(n + <span class=\"number\">200</span>), n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">m, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 with <span class=\"subst\">$&#123;m&#125;</span> and <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(m + n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">k, m, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 with <span class=\"subst\">$&#123;k&#125;</span>, <span class=\"subst\">$&#123;m&#125;</span> and <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(k + m + n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Promise方式调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    step1(time1)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step2(time1, time2)</span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> [time1, time2, time3]);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">times</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> [time1, time2, time3] = times;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step3(time1, time2, time3);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// step1 with 300</span></span><br><span class=\"line\"><span class=\"comment\">// step2 with 300 and 500</span></span><br><span class=\"line\"><span class=\"comment\">// step3 with 300, 500 and 1000</span></span><br><span class=\"line\"><span class=\"comment\">// result is 2000</span></span><br><span class=\"line\"><span class=\"comment\">// doIt: 2913.488037109375ms</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：这里为什么不能直接这样写promise式调用，因为中间参数 time2、time3都没有办法保存</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    step1(time1)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> step2(time1, time2))</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> step3(time1, time2, time3))</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// async/await方式调用</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time2 = <span class=\"keyword\">await</span> step1(time1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time3 = <span class=\"keyword\">await</span> step2(time1, time2);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> step3(time1, time2, time3);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// step1 with 300</span></span><br><span class=\"line\"><span class=\"comment\">// step2 with 300 and 500</span></span><br><span class=\"line\"><span class=\"comment\">// step3 with 300, 500 and 1000</span></span><br><span class=\"line\"><span class=\"comment\">// result is 2000</span></span><br><span class=\"line\"><span class=\"comment\">// doIt: 2913.488037109375ms</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关于协程\"><a href=\"#关于协程\" class=\"headerlink\" title=\"关于协程\"></a>关于协程</h3><details>\n<summary>关于协程</summary>\n\n<ul>\n<li><p>进程&gt;线程&gt;协程</p>\n</li>\n<li><p>协程的第一大优势是具有极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p>\n</li>\n<li><p>协程的第二大优势是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多；</p>\n</li>\n<li><p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行，需要注意的是：在一个子程序中中断，去执行其他子程序，这并不是函数调用，有点类似于CPU的中断；</p>\n<blockquote>\n<p>用汽车和公路举个例子：js公路只是单行道（主线程），但是有很多车道（辅助线程）都可以汇入车流（异步任务完成后回调进入主线程的任务队列）；generator把js公路变成了多车道（协程实现），但是同一时间只有一个车道上的车能开（依然单线程），不过可以自由变道（移交控制权）；</p>\n</blockquote>\n</li>\n<li><p>协程意思是多个线程互相协作，完成异步任务，运行流程大致如下：<br>  1）协程A开始执行；<br>  2）协程A执行到一半，进入暂停，执行权转移到协程B；<br>  3）一段时间后，协程B交还执行权；<br>  4）协程A恢复执行；</p>\n</li>\n<li><p>协程是一个无优先级的子程序调度组件，允许子程序在特定的地点挂起恢复；</p>\n</li>\n<li><p>线程包含于进程，协程包含于线程，只要内存足够，一个线程中可以有任意多个协程，但某一个时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源；</p>\n</li>\n<li><p>就实际使用理解来说，协程允许我们写同步代码的逻辑，却做着异步的事，避免了回调嵌套，使得代码逻辑清晰；</p>\n</li>\n<li><p>何时挂起，唤醒协程：协程是为了使用异步的优势，异步操作是为了避免IO操作阻塞线程，那么协程挂起的时刻应该是当前协程发起异步操作的时候，而唤醒应该在其他协程退出，并且他的异步操作完成时；</p>\n</li>\n<li><p>单线程内开启协程，一旦遇到io，从应用程序级别（而非操作系统）控制切换对比操作系统控制线程的切换，用户在单线程内控制协程的切换，优点如下：<br>1）协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级；<br>2）单线程内就可以实现并发的效果，最大限度地利用cpu；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\">def consumer():</span><br><span class=\"line\">    r = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> True:</span><br><span class=\"line\">        n = <span class=\"keyword\">yield</span> r</span><br><span class=\"line\">        <span class=\"keyword\">if</span> not n:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        print(<span class=\"string\">'[CONSUMER] Consuming %s...'</span> % n)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        r = <span class=\"string\">'200 OK'</span></span><br><span class=\"line\"></span><br><span class=\"line\">def produce(c):</span><br><span class=\"line\">    c.next()</span><br><span class=\"line\">    n = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &lt; <span class=\"number\">5</span>:</span><br><span class=\"line\">        n = n + <span class=\"number\">1</span></span><br><span class=\"line\">        print(<span class=\"string\">'[PRODUCER] Producing %s...'</span> % n)</span><br><span class=\"line\">        r = c.send(n)</span><br><span class=\"line\">        print(<span class=\"string\">'[PRODUCER] Consumer return: %s'</span> % r)</span><br><span class=\"line\">    c.close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    c = consumer()</span><br><span class=\"line\">    produce(c)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[PRODUCER] Producing <span class=\"number\">1.</span>..</span><br><span class=\"line\">[CONSUMER] Consuming <span class=\"number\">1.</span>..</span><br><span class=\"line\">[PRODUCER] Consumer <span class=\"keyword\">return</span>: <span class=\"number\">200</span> OK</span><br><span class=\"line\">[PRODUCER] Producing <span class=\"number\">2.</span>..</span><br><span class=\"line\">[CONSUMER] Consuming <span class=\"number\">2.</span>..</span><br><span class=\"line\">[PRODUCER] Consumer <span class=\"keyword\">return</span>: <span class=\"number\">200</span> OK</span><br><span class=\"line\">[PRODUCER] Producing <span class=\"number\">3.</span>..</span><br><span class=\"line\">[CONSUMER] Consuming <span class=\"number\">3.</span>..</span><br><span class=\"line\">[PRODUCER] Consumer <span class=\"keyword\">return</span>: <span class=\"number\">200</span> OK</span><br><span class=\"line\">[PRODUCER] Producing <span class=\"number\">4.</span>..</span><br><span class=\"line\">[CONSUMER] Consuming <span class=\"number\">4.</span>..</span><br><span class=\"line\">[PRODUCER] Consumer <span class=\"keyword\">return</span>: <span class=\"number\">200</span> OK</span><br><span class=\"line\">[PRODUCER] Producing <span class=\"number\">5.</span>..</span><br><span class=\"line\">[CONSUMER] Consuming <span class=\"number\">5.</span>..</span><br><span class=\"line\">[PRODUCER] Consumer <span class=\"keyword\">return</span>: <span class=\"number\">200</span> OK</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：</p>\n<ul>\n<li>首先调用c.next()启动生成器；</li>\n<li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</li>\n<li>consumer通过yield拿到消息，处理，又通过yield把结果传回；</li>\n<li>produce拿到consumer处理的结果，继续生产下一条消息；</li>\n<li>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</li>\n</ul>\n<p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p>\n</details>\n\n<p>参考链接：<a href=\"https://www.jianshu.com/p/73b070eebf50\" target=\"_blank\" rel=\"noopener\">async/await的基础用法</a></p>\n","categories":[],"tags":["ES6","异步"]},{"title":"vue css中/deep/深度选择","url":"https://Xmtd.github.io/2019/11/15/deepcss/","content":"<h3 id=\"vue-css中-deep-用法\"><a href=\"#vue-css中-deep-用法\" class=\"headerlink\" title=\"vue css中/deep/用法\"></a>vue css中/deep/用法</h3><p><code>/deep/</code>的意思大概为深入的，深远的（深度选择）。Scoped CSS规范是Web组件产生不污染其他组件，也不被其他组件污<br>染的CSS规范。这样在打包的时候会生成一个独一无二hash值，这样父组件的样式就不会影响到子组件了；再用别人或者第三<br>方组件是，要是想修改其组件的样式，一般都是提取公共文件，但是存在问题是有时候你修改一处就可能影响到别的地方，这<br>个时候就可以需要一种方式，既不影响别的地方，又能修改子组件的样式。</p>\n<ul>\n<li><em>加入scoped属性</em></li>\n</ul>\n<p><img src=\"/images/WechatIMG8282.png\" alt=\"avatar\"><br><img src=\"/images/WechatIMG86.png\" alt=\"avatar\"><br>可以看出，scoped属性会将 template 中的每个元素加入 [data-v-xxxx]的hash值，但如果引用了第三方组件，<code>默认只会对组件的最外层（div）加入这个 [data-v-xxxx] 属性，但第二层开始就没有效果了</code>，如上图所示，第一层el-tabs加上了[data-v-xxxx]，底下<br>的el-tabs__header就没有了</p>\n<ul>\n<li><em>这个时候修改样式，未加/deep/</em></li>\n</ul>\n<p><img src=\"/images/WechatIMG85.png\" alt=\"avatar\"><br><img src=\"/images/noDeep.png\" alt=\"avatar\"><br>编译后的css可以看出，寻找的路径为<code>.m-transaction-details-wrapper .el-tabs .el-tabs__header[data-v-5419d6af]</code><br>但是在看html元素上，并没有在<code>.el-tabs__header</code>加入[data-v-5419d6af]，所以导致不生效</p>\n<ul>\n<li><em>加上/deep/</em></li>\n</ul>\n<p><img src=\"/images/WechatIMG87.png\" alt=\"avatar\"><br><img src=\"/images/deep.png\" alt=\"avatar\"><br>此时编译后的css寻找路径为<code>.m-transaction-details-wrapper[data-v-5419d6af] .el-tabs .el-tabs__header</code>,就可以生<br>效了，这类似于css module中的global属性，加上global修改第三方组件才能生效</p>\n","categories":[],"tags":["css","vue"]},{"title":"Hello World","url":"https://Xmtd.github.io/2019/11/04/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">启动</span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">清楚缓存</span><br><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","categories":[],"tags":[]},{"title":"lodash之concat","url":"https://Xmtd.github.io/2019/10/18/lodash之concat/","content":"<p>function copyArray(source, array) {<br>    var index = -1,<br>        length = source.length;</p>\n<pre><code>// 这里判断 array 是否为 undefined，如果是就定义一个与 source 长度相等的数组。\narray || (array = Array(length));\n\nwhile (++index &lt; length) {\n    array[index] = source[index];\n}\nreturn array;</code></pre><p>}</p>\n<p>// arrayPush方法是在传入的参数array基础上进行拼接的<br>function arrayPush(array, values) {<br>    var index = -1,<br>        length = values.length,<br>        offset = array.length;</p>\n<pre><code>while (++index &lt; length) {\n    array[offset + index] = values[index];\n}\nreturn array;\n/**\n * 举例分析：\n * arrayPush([1,2,3], [4, [5]]);\n * 刚进来 index = -1;  length = 2; offset = 3;\n * 进入循环\n * index = 0; offset + index = 3; array[3] = values[0] = 4;\n * index = 1; offset + index = 4; array[4] = values[1] = [5];\n * index = 2; 停止循环\n *\n * array = [1,2,3,4,[5]]\n *\n */</code></pre><p>}</p>\n<p>var isArray = Array.isArray;</p>\n<p>// 这个方法是在判断 value 是否是可以被打平的 arguments 对象或者数组。如果是，返回 true，若不是，则返回 false<br>function isFlattenable(value) {<br>    return isArray(value) || isArguments(value) ||<br>        !!(spreadableSymbol &amp;&amp; value &amp;&amp; value[spreadableSymbol]);<br>}</p>\n<p>/**<br> *</p>\n<ul>\n<li><p>@param array</p>\n</li>\n<li><p>@param depth</p>\n</li>\n<li><p>@param predicate  每次迭代调用的函数</p>\n</li>\n<li><p>@param isStrict   限制</p>\n</li>\n<li><p>@param result</p>\n</li>\n<li><p>@returns {Array}</p>\n</li>\n<li><p>/<br>// 减少嵌套数组<br>function baseFlatten(array, depth, predicate, isStrict, result) {   // 2, [3], [4], -1: [1]<br>  var index = -1,</p>\n<pre><code>length = array.length;</code></pre><p>  // 判断是否传入 predicate, 若没有，将方法 isFlattenable 赋值给 predicate<br>  predicate || (predicate = isFlattenable);</p>\n<p>  result || (result = []);</p>\n<p>  //[1,[3], [4, [5]]]</p>\n<p>  while (++index &lt; length) {</p>\n<pre><code>var value = array[index];\nif (depth &gt; 0 &amp;&amp; predicate(value)) {\n    if (depth &gt; 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n    } else {\n        arrayPush(result, value);\n    }\n} else if (!isStrict) {\n    result[result.length] = value;\n}</code></pre><p>  }<br>  return result;<br>}</p>\n</li>\n</ul>\n<p>// 源码<br>// _.concat(array, [values])  创建一个新数组，将array与任何数组 或 值连接在一起<br>/**<br>var array = [1];<br>var other = _.concat(array, 2, [3], [[4]]);</p>\n<p>console.log(other);<br>// =&gt; [1, 2, 3, [4]]</p>\n<p>console.log(array);<br>*/<br>function concat() {  // [1], 2, [3], [4]<br>    // 获取参数个数<br>    var length = arguments.length;</p>\n<pre><code>if (!length) {\n    return [];\n}\n\nvar args = Array(length - 1),   // 去除0索引以外的参数\n    array = arguments[0],      // 第一个元素\n    index = length;\n\n// 从后往前添加\nwhile (index--) {\n    args[index - 1] = arguments[index];\n    /**\n     * 4 index = 3;  args[2] = arguments[3] = [4];\n     * 3 index = 2;  args[1] = arguments[2] = [3];\n     * 2 index = 1;  args[0] = arguments[1] = 2;\n     * 1 index = 0;  args[-1] = arguments[0] = [1];\n     * args = [2, [3], [4], -1: [1]]\n     */\n}\nreturn arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));</code></pre><p>}</p>\n","categories":[],"tags":["源码"]},{"title":"搜索","url":"https://Xmtd.github.io/search/index.html","content":"","categories":[],"tags":[]}]