<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>async/await 用法整理 | Xmtd</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="mtd,mtd's Blog" />
  
  <meta name="description" content="它最受欢迎的地方：能让异步代码写起来像同步代码，并且方便控制顺序。 async&#x2F;await 概念解释 async  async的用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行，async 函数返回的是一个promise 对象。   await  await的含义为等待。意思就是代码需要等待awai">
<meta name="keywords" content="ES6,异步">
<meta property="og:type" content="article">
<meta property="og:title" content="async&#x2F;await 用法整理">
<meta property="og:url" content="https:&#x2F;&#x2F;xmtd.github.io&#x2F;2019&#x2F;11&#x2F;18&#x2F;async-await&#x2F;index.html">
<meta property="og:site_name" content="Xmtd">
<meta property="og:description" content="它最受欢迎的地方：能让异步代码写起来像同步代码，并且方便控制顺序。 async&#x2F;await 概念解释 async  async的用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行，async 函数返回的是一个promise 对象。   await  await的含义为等待。意思就是代码需要等待awai">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-11-18T07:28:50.136Z">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>
  

  
  

</head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">mtd&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        mtd&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        一个专注 WEB 开发的技术博客
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-async-await" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      async/await 用法整理
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2019-11-18
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <p>它最受欢迎的地方：<strong>能让异步代码写起来像同步代码，并且方便控制顺序。</strong></p>
<h3 id="async-await-概念解释"><a href="#async-await-概念解释" class="headerlink" title="async/await 概念解释"></a>async/await 概念解释</h3><ul>
<li><p>async</p>
<blockquote>
<p>async的用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行，async 函数返回的是一个promise 对象。</p>
</blockquote>
</li>
<li><p>await</p>
<blockquote>
<p>await的含义为等待。意思就是代码需要等待await后面的函数运行完并且有了返回结果之后，才继续执行下面的代码。这正是同步的效果。</p>
</blockquote>
</li>
</ul>
<h3 id="async函数是Generator函数的语法糖，并对Generator函数进行了改进。"><a href="#async函数是Generator函数的语法糖，并对Generator函数进行了改进。" class="headerlink" title="async函数是Generator函数的语法糖，并对Generator函数进行了改进。"></a>async函数是Generator函数的语法糖，并对Generator函数进行了改进。</h3><h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a><em>简介</em></h5><ul>
<li>Generator 函数是一个状态机，封装了多个内部状态。执行Generator函数会返回一个<a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">遍历器对象</a>，可以依次遍历Generator函数的每一个状态，<br>但是只有调用<code>next</code>方法才能遍历到下一个状态，所以其实提供了一种暂停执行函数，<code>yield</code>表达式就是暂停标志。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line"></span><br><span class="line">hw.next()<span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">hw.next()<span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line">hw.next()<span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">hw.next()<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，helloWorldGenerator函数被调用时并没有执行，而是返回了一个遍历器对象，只有调用<code>next</code>方法、内部指针指向该语句时才执行，每次调用next方法，就回返回一个对象包含<code>value</code>和<br><code>done</code>两个属性，<code>value</code>属性表示内部状态的值，是yield表达式后面表达式返回的值；<code>done</code>属性是个布尔值，表示是否遍历结束。即实现了<code>函数可以暂停，也可恢复执行</code></p>
<h5 id="Generator暂停恢复执行原理"><a href="#Generator暂停恢复执行原理" class="headerlink" title="Generator暂停恢复执行原理"></a><em>Generator暂停恢复执行原理</em></h5><p>要懂得原理，得了解协程的概念</p>
<blockquote>
<p>一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），<br>等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>
</blockquote>
<p>协程是一种比线程更加轻量级的存在。普通线程是抢先式的，会争夺cpu资源，而协程是合作的，可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。它的运行流程大致如下：</p>
<ol>
<li>协程A开始执行</li>
<li>协程A执行到某个阶段，进入暂停，执行权转移到协程B</li>
<li>协程B执行完成或暂停，将执行权交还A</li>
<li>协程A恢复执行</li>
</ol>
<p>协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<h5 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a><em>执行器</em></h5><p>通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器,<code>co</code> 模块就是一个著名的执行器。</p>
<p>Generator 是一个异步操作的容器。它是需要手动执行的，它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。两种方法可以做到这一点：</p>
<pre><code>1. 回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。
2. Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权</code></pre><p>一个基于 Promise 对象的简单自动执行器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = gen();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">    result.value.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      next(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> response1 = <span class="keyword">yield</span> fetch(<span class="string">'https://xxx'</span>) <span class="comment">//返回promise对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'response1'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(response1)</span><br><span class="line">    <span class="keyword">let</span> response2 = <span class="keyword">yield</span> fetch(<span class="string">'https://xxx'</span>) <span class="comment">//返回promise对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'response2'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(response2)</span><br><span class="line">&#125;</span><br><span class="line">run(foo);</span><br></pre></td></tr></table></figure>
<p>上面代码中，只要 Generator 函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p>
<h5 id="async的改进"><a href="#async的改进" class="headerlink" title="async的改进"></a><em>async的改进</em></h5><p>async彻底告别了执行器和生成器，实现更加直观简洁的代码，async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。可以说async 是Generator函数的语法糖，并对Generator函数进行了改进。</p>
<p>async函数对 Generator 函数的改进，体现在以下四点：</p>
<pre><code>1. 内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。
2. 更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果
3. 更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。
4. 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用</code></pre><h3 id="async-await-与-promise-相比的优势"><a href="#async-await-与-promise-相比的优势" class="headerlink" title="async/await 与 promise 相比的优势"></a>async/await 与 promise 相比的优势</h3><ol>
<li><p><strong>同步代码编写方式</strong>:</p>
<ul>
<li>用同步的思维来解决异步问题的方案。</li>
<li>Promise使用then函数进行链式调用，一直点点点，是一种从左向右的横向写法；</li>
<li>async/await从上到下，顺序执行，就像写同步代码一样，更符合代码编写习惯。</li>
</ul>
</li>
<li><p><strong>多个参数传递</strong>:</p>
<ul>
<li>Promise的then函数只能传递一个参数，虽然可以通过包装成对象来传递多个参数，但是会导致传递冗余信息，比较麻烦；</li>
<li>async/await没有这个限制，可以当做普通的局部变量来处理，用let或者const定义的块级变量想怎么用就怎么用，完全没有限制；</li>
</ul>
</li>
<li><p><strong>同步代码和异步代码可以一起编写</strong>:</p>
<ul>
<li>使用Promise的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰；</li>
<li>async/await整个书写习惯都是同步的，不需要纠结同步和异步的区别，当然，异步过程需要包装成一个Promise对象放在await关键字后面；</li>
</ul>
</li>
<li><p><strong>基于协程</strong>:</p>
<ul>
<li>Promise是根据函数式编程的范式，对异步过程进行了一层封装；</li>
<li>async/await基于协程的机制，是真正的“保存上下文，控制权切换……控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述；</li>
</ul>
</li>
<li><p>✨<strong>这点并不是优势也不算劣势（只能串行）</strong>:<br> 它不能取代 Promise，尤其是我们可以很方便地用Promise.all()来实现并发，而async/await只能实现串行。</p>
</li>
</ol>
<h3 id="async关键字"><a href="#async关键字" class="headerlink" title="async关键字"></a>async关键字</h3><blockquote>
<p>async函数执行和普通函数一样，函数名带个()就可以了，参数个数随意，没有限制，也需要有async关键字；只是返回值是一个Promise对象，可以用then函数得到返回值，用catch抓整个流程中发生的错误；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello async"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = testAsync(); <span class="comment">// 返回一个Promise对象</span></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// async函数返回的是一个Promise对象，async函数（包括函数语句、函数表达式、Lambda表</span></span><br><span class="line"><span class="comment">// 达式）会返回一个Promise对象，如果在函数中return一个直接量，async会把这个直接量通</span></span><br><span class="line"><span class="comment">// 过Promise.resolve() 封装成 Promise 对象；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数返回的是一个Promise对象，所以在最外层不能用await获取其返回值的情况，</span></span><br><span class="line"><span class="comment">// 应该使用原始的方式：then()链来处理这个Promise对象</span></span><br><span class="line">testAsync().then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);    <span class="comment">// 输出 hello async</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>表明程序里面可能有异步过程：</strong></p>
<ul>
<li>async关键字表明程序里面可能有异步过程，里面可以有await关键字；</li>
<li>当然全部是同步代码也没关系，但是这样async关键字就显得多余了；</li>
</ul>
</li>
<li><p><strong>非阻塞，无等待：</strong></p>
<ul>
<li>async函数里面如果有异步过程会等待，但是<code>async函数本身会马上返回</code>，不会阻塞当前线程;</li>
<li>可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染，async函数内部由await关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回；</li>
<li>在没有await的情况下执行async函数，它会立即执行，返回一个Promise对象，并且绝对不会阻塞后面的语句，这和普通返回Promise对象的函数并无二致；</li>
</ul>
</li>
<li><p><strong>async函数返回类型为Promise对象：</strong><br> 这是和普通函数本质上不同的地方，也是使用时重点注意的地方；</p>
<ul>
<li>（1）return newPromise()；这个符合async函数本意；</li>
<li>（2）return data；这个是同步函数的写法，这里是要特别注意的，这个时候，其实就相当于Promise.resolve(data)；还是一个Promise对象，但是在调用async函数的地方通过简单的=是拿不到这个data的，因为返回值是一个Promise对象，所以需要用.then(data =&gt; { })函数才可以拿到这个data；</li>
<li>（3）如果没有返回值，相当于返回了Promise.resolve(undefined)；</li>
</ul>
</li>
<li><p><strong>async统一catch，await不处理异步error：</strong><br> async函数返回的这个Promise对象的catch函数负责统一抓取内部所有异步过程的错误，await是不管异步过程的reject(error)消息的；</p>
</li>
</ol>
<h3 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h3><ol>
<li><p><strong>await只能在async函数内部使用：</strong><br> 不能放在普通函数里面，否则会报错；</p>
</li>
<li><p><strong>await后面也可以跟同步代码：</strong><br> 不过系统会自动将其转化成一个Promsie对象，比如：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">await</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟同步代码是一样的，还不如省事点，直接去掉await关键字</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'hello world'</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>✨<strong>await对于失败消息的处理：</strong><br> await只关心异步过程成功的消息resolve(data)，拿到相应的数据data，至于失败消息reject(error)，不关心不处理；对于错误的处理有以下几种方法供选择：</p>
<ol>
<li>让await后面的Promise对象自己catch；</li>
<li>也可以让外面的async函数返回的Promise对象统一catch；</li>
<li>像同步代码一样，放在一个try…catch结构中；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是React Native的回调函数，加个async关键字，没有任何影响，但是可以用await关键字</span></span><br><span class="line"><span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 将异步和同步的代码放在一个try..catch中，异常都能抓到</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> array = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">await</span> asyncFunction();  <span class="comment">// 这里用await关键字，就能拿到结果值；否则，没有await的话，只能拿到Promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (array.length &gt; <span class="number">0</span>) &#123;  <span class="comment">// 这里会抛出异常，下面的catch也能抓到</span></span><br><span class="line">            array.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        alert(<span class="built_in">JSON</span>.stringify(error))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="使用方式实践"><a href="#使用方式实践" class="headerlink" title="使用方式实践"></a>使用方式实践</h3><h4 id="（1）像写同步代码那样，定义异步流程"><a href="#（1）像写同步代码那样，定义异步流程" class="headerlink" title="（1）像写同步代码那样，定义异步流程"></a>（1）像写同步代码那样，定义异步流程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步过程封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'sleep for '</span> + ms + <span class="string">' ms'</span>);</span><br><span class="line">        &#125;, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义异步流程，就像写同步代码那样</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'asyncFunction total executing:'</span>);</span><br><span class="line">    <span class="keyword">const</span> sleep1 = <span class="keyword">await</span> sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep1: '</span> + sleep1);</span><br><span class="line">    <span class="keyword">const</span> [sleep2, sleep3, sleep4]= <span class="keyword">await</span> <span class="built_in">Promise</span>.all([sleep(<span class="number">2000</span>), sleep(<span class="number">1000</span>), sleep(<span class="number">1500</span>)]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep2: '</span> + sleep2);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep3: '</span> + sleep3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep4: '</span> + sleep4);</span><br><span class="line">    <span class="keyword">const</span> sleepRace = <span class="keyword">await</span> <span class="built_in">Promise</span>.race([sleep(<span class="number">3000</span>), sleep(<span class="number">1000</span>), sleep(<span class="number">1000</span>)]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep race: '</span> + sleepRace);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'asyncFunction total executing:'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'asyncFunction done.'</span>  <span class="comment">// 这个可以不返回，这里只是做个标记，为了显示流程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像普通函数调用async函数，在then函数中获取整个流程的返回信息，</span></span><br><span class="line"><span class="comment">// 在catch函数统一处理出错信息</span></span><br><span class="line">asyncFunction().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// asyncFunction return 的内容在这里获取: 'asyncFunction done.'</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// asyncFunction 的错误统一在这里抓取</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个代表asyncFunction函数后的代码，</span></span><br><span class="line"><span class="comment">// 显示asyncFunction本身会立即返回，不会阻塞主线程</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after asyncFunction code executing....'</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">after asyncFunction code executing....</span><br><span class="line">sleep1: sleep <span class="keyword">for</span> <span class="number">2000</span> ms</span><br><span class="line">sleep2: sleep <span class="keyword">for</span> <span class="number">2000</span> ms</span><br><span class="line">sleep3: sleep <span class="keyword">for</span> <span class="number">1000</span> ms</span><br><span class="line">sleep4: sleep <span class="keyword">for</span> <span class="number">1500</span> ms</span><br><span class="line">sleep race: sleep <span class="keyword">for</span> <span class="number">1000</span> ms</span><br><span class="line">asyncFunction total executing:: <span class="number">5006.276123046875</span>ms</span><br><span class="line">asyncFunction done.</span><br><span class="line"></span><br><span class="line"><span class="comment">// console输出：</span></span><br><span class="line"><span class="built_in">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line">    __proto__: <span class="built_in">Promise</span></span><br><span class="line">    [[PromiseStatus]]: <span class="string">"resolved"</span></span><br><span class="line">    [[PromiseValue]]: <span class="string">"asyncFunction done."</span></span><br><span class="line">VM12229:<span class="number">5</span> sleep1: sleep <span class="keyword">for</span> <span class="number">2000</span> ms</span><br><span class="line">VM12229:<span class="number">7</span> sleep2: sleep <span class="keyword">for</span> <span class="number">2000</span> ms</span><br><span class="line">VM12229:<span class="number">8</span> sleep3: sleep <span class="keyword">for</span> <span class="number">1000</span> ms</span><br><span class="line">VM12229:<span class="number">9</span> sleep4: sleep <span class="keyword">for</span> <span class="number">1500</span> ms</span><br><span class="line">VM12229:<span class="number">11</span> sleep race: sleep <span class="keyword">for</span> <span class="number">1000</span> ms</span><br><span class="line">VM12229:<span class="number">12</span> asyncFunction total executing:: <span class="number">5004.796875</span>ms</span><br></pre></td></tr></table></figure>
<p>代码分析：</p>
<ul>
<li>after asyncFunction code executing….代码位置在async函数asyncFunction()调用之后，反而先输出，这说明async函数asyncFunction()调用之后会马上返回，不会阻塞主线程；</li>
<li>sleep1: sleep for 2000 ms这是第一个await之后的第一个异步过程，最先执行，也最先完成，说明后面的代码，不论是同步和异步，都在等他执行完毕；</li>
<li>sleep2 ~ sleep4这是第二个await之后的Promise.all()异步过程，这是“比慢模式”，三个sleep都完成后，再运行下面的代码，耗时最长的是2000ms；</li>
<li>sleep race: sleep for 1000 ms这是第三个await之后的Promise.race()异步过程，这是“比快模式”，耗时最短sleep都完成后，就运行下面的代码，耗时最短的是1000ms；</li>
<li>asyncFunction total executing:: 5006.276123046875ms这是最后的统计总共运行时间代码，三个await之后的异步过程之和：<blockquote>
<p>1000（独立的） + 2000（Promise.all） + 1000（Promise.race） = 5000ms</p>
</blockquote>
</li>
<li>这个和统计出来的5006.276123046875ms非常接近，说明上面的异步过程，和同步代码执行过程一致，协程真的是在等待异步过程执行完毕；</li>
<li>asyncFunction done.这个是async函数返回的信息，在执行时的then函数中获得，说明整个流程完毕之后参数传递的过程；</li>
</ul>
<h4 id="（2）顺序执行，结果作为下一次输入"><a href="#（2）顺序执行，结果作为下一次输入" class="headerlink" title="（2）顺序执行，结果作为下一次输入"></a>（2）顺序执行，结果作为下一次输入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span></span><br><span class="line"><span class="comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise方式调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))</span><br><span class="line">        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br><span class="line"></span><br><span class="line"><span class="comment">// c:\var\test&gt;node --harmony_async_await .</span></span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 500</span></span><br><span class="line"><span class="comment">// step3 with 700</span></span><br><span class="line"><span class="comment">// result is 900</span></span><br><span class="line"><span class="comment">// doIt: 1507.251ms</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async/await方式调用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure>

<h4 id="（3）中间参数需要保留"><a href="#（3）中间参数需要保留" class="headerlink" title="（3）中间参数需要保留"></a>（3）中间参数需要保留</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span></span><br><span class="line"><span class="comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(m + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">k, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;k&#125;</span>, <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(k + m + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise方式调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> step2(time1, time2)</span><br><span class="line">                .then(<span class="function"><span class="params">time3</span> =&gt;</span> [time1, time2, time3]);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">times</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> [time1, time2, time3] = times;</span><br><span class="line">            <span class="keyword">return</span> step3(time1, time2, time3);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br><span class="line"></span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 300 and 500</span></span><br><span class="line"><span class="comment">// step3 with 300, 500 and 1000</span></span><br><span class="line"><span class="comment">// result is 2000</span></span><br><span class="line"><span class="comment">// doIt: 2913.488037109375ms</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里为什么不能直接这样写promise式调用，因为中间参数 time2、time3都没有办法保存</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time1, time2))</span><br><span class="line">        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time1, time2, time3))</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async/await方式调用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time1, time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time1, time2, time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br><span class="line"></span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 300 and 500</span></span><br><span class="line"><span class="comment">// step3 with 300, 500 and 1000</span></span><br><span class="line"><span class="comment">// result is 2000</span></span><br><span class="line"><span class="comment">// doIt: 2913.488037109375ms</span></span><br></pre></td></tr></table></figure>

<h3 id="关于协程"><a href="#关于协程" class="headerlink" title="关于协程"></a>关于协程</h3><details>
<summary>关于协程</summary>

<ul>
<li><p>进程&gt;线程&gt;协程</p>
</li>
<li><p>协程的第一大优势是具有极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p>
</li>
<li><p>协程的第二大优势是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多；</p>
</li>
<li><p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行，需要注意的是：在一个子程序中中断，去执行其他子程序，这并不是函数调用，有点类似于CPU的中断；</p>
<blockquote>
<p>用汽车和公路举个例子：js公路只是单行道（主线程），但是有很多车道（辅助线程）都可以汇入车流（异步任务完成后回调进入主线程的任务队列）；generator把js公路变成了多车道（协程实现），但是同一时间只有一个车道上的车能开（依然单线程），不过可以自由变道（移交控制权）；</p>
</blockquote>
</li>
<li><p>协程意思是多个线程互相协作，完成异步任务，运行流程大致如下：<br>  1）协程A开始执行；<br>  2）协程A执行到一半，进入暂停，执行权转移到协程B；<br>  3）一段时间后，协程B交还执行权；<br>  4）协程A恢复执行；</p>
</li>
<li><p>协程是一个无优先级的子程序调度组件，允许子程序在特定的地点挂起恢复；</p>
</li>
<li><p>线程包含于进程，协程包含于线程，只要内存足够，一个线程中可以有任意多个协程，但某一个时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源；</p>
</li>
<li><p>就实际使用理解来说，协程允许我们写同步代码的逻辑，却做着异步的事，避免了回调嵌套，使得代码逻辑清晰；</p>
</li>
<li><p>何时挂起，唤醒协程：协程是为了使用异步的优势，异步操作是为了避免IO操作阻塞线程，那么协程挂起的时刻应该是当前协程发起异步操作的时候，而唤醒应该在其他协程退出，并且他的异步操作完成时；</p>
</li>
<li><p>单线程内开启协程，一旦遇到io，从应用程序级别（而非操作系统）控制切换对比操作系统控制线程的切换，用户在单线程内控制协程的切换，优点如下：<br>1）协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级；<br>2）单线程内就可以实现并发的效果，最大限度地利用cpu；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">def consumer():</span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> not n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">'[CONSUMER] Consuming %s...'</span> % n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"></span><br><span class="line">def produce(c):</span><br><span class="line">    c.next()</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[PRODUCER] Producing %s...'</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(<span class="string">'[PRODUCER] Consumer return: %s'</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[PRODUCER] Producing <span class="number">1.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">1.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">2.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">2.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">3.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">3.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">4.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">4.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br><span class="line">[PRODUCER] Producing <span class="number">5.</span>..</span><br><span class="line">[CONSUMER] Consuming <span class="number">5.</span>..</span><br><span class="line">[PRODUCER] Consumer <span class="keyword">return</span>: <span class="number">200</span> OK</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：</p>
<ul>
<li>首先调用c.next()启动生成器；</li>
<li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</li>
<li>consumer通过yield拿到消息，处理，又通过yield把结果传回；</li>
<li>produce拿到consumer处理的结果，继续生产下一条消息；</li>
<li>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</li>
</ul>
<p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p>
</details>

<p>参考链接：<a href="https://www.jianshu.com/p/73b070eebf50" target="_blank" rel="noopener">async/await的基础用法</a></p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2019年11月18日 15:28</p>
        <p>原始链接： <a class="post-url" href="/2019/11/18/async-await/" title="async/await 用法整理">https://xmtd.github.io/2019/11/18/async-await/</a></p>
        <footer>
            <a href="https://Xmtd.github.io">
                <img src="/images/logo.png" alt="mtd">
                mtd
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" target="_blank" rel="noopener">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" target="_blank" rel="noopener" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/WechatIMG1.png" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/WechatIMG1.png">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" target="_blank" rel="noopener" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://xmtd.github.io/2019/11/18/async-await/&title=《async/await 用法整理》 — Xmtd&pic=/images/WechatIMG3.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" target="_blank" rel="noopener" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://xmtd.github.io/2019/11/18/async-await/&title=《async/await 用法整理》 — Xmtd&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://xmtd.github.io/2019/11/18/async-await/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《async/await 用法整理》 — Xmtd&url=https://xmtd.github.io/2019/11/18/async-await/&via=https://Xmtd.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://xmtd.github.io/2019/11/18/async-await/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" target="_blank" rel="noopener" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://xmtd.github.io/2019/11/18/async-await/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/ES6/" class="color4">ES6</a>
      
    <a href="/tags/异步/" class="color3">异步</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#async-await-概念解释"><span class="post-toc-text">async/await 概念解释</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#async函数是Generator函数的语法糖，并对Generator函数进行了改进。"><span class="post-toc-text">async函数是Generator函数的语法糖，并对Generator函数进行了改进。</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Generator函数"><span class="post-toc-text">Generator函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#简介"><span class="post-toc-text">简介</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Generator暂停恢复执行原理"><span class="post-toc-text">Generator暂停恢复执行原理</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#执行器"><span class="post-toc-text">执行器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#async的改进"><span class="post-toc-text">async的改进</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#async-await-与-promise-相比的优势"><span class="post-toc-text">async/await 与 promise 相比的优势</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#async关键字"><span class="post-toc-text">async关键字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#await关键字"><span class="post-toc-text">await关键字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用方式实践"><span class="post-toc-text">使用方式实践</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（1）像写同步代码那样，定义异步流程"><span class="post-toc-text">（1）像写同步代码那样，定义异步流程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（2）顺序执行，结果作为下一次输入"><span class="post-toc-text">（2）顺序执行，结果作为下一次输入</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（3）中间参数需要保留"><span class="post-toc-text">（3）中间参数需要保留</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#关于协程"><span class="post-toc-text">关于协程</span></a></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2019/11/25/http-server/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          http server
        
      </span>
    </a>
  
  
    <a href="/2019/11/15/deepcss/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">vue css中/deep/深度选择</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
    <link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
<script src="https://billts.site/js/gitment.js"></script>
    <div id="comments">
        <script>
            var gitment = new Gitment({
                id: 'async/await 用法整理',
                owner: 'Xmtd',
                repo: 'xmtd-comments',
                oauth: {
                    client_id: '2a738abad82fbbd94bcd',
                    client_secret: 'ce7e20bbeb80416391ce94fa9e3b7354273b6ac4',
                },
            })
            gitment.render('comments')
        </script>
    </div>

    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2019 mtd<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://Xmtd.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/server/" style="font-size: 10px;">server</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E5%BC%82%E6%AD%A5/" style="font-size: 10px;">异步</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 10px;">源码</a>
        </div>
    </div>
    <a href="javascript:;" target="_blank" rel="noopener" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/server/" style="font-size: 10px;">server</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E5%BC%82%E6%AD%A5/" style="font-size: 10px;">异步</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 10px;">源码</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" target="_blank" rel="noopener" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;" target="_blank" rel="noopener">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/js/search.js"></script>
<script src="/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/js/animate.js"></script>


  <script src="/js/pop-img.js"></script>
  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":200,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"dialog":{"enable":true,"script":{"every idle 10s":"$hitokoto$","hover .star":"星星在天上而你在我心里 (*/ω＼*)","tap body":"哎呀！别碰我！","tap face":"人家已经不是小孩子了！"}},"log":false});</script></body>
</html>