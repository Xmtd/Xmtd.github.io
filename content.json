{"meta":{"title":"Xmtd","subtitle":null,"description":null,"author":"mtd","url":"https://Xmtd.github.io","root":"/"},"pages":[{"title":"搜索","date":"2019-10-18T08:24:36.000Z","updated":"2019-10-18T06:10:19.517Z","comments":false,"path":"search/index.html","permalink":"https://xmtd.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"vue css中/deep/深度选择","slug":"deepcss","date":"2019-11-15T06:41:29.000Z","updated":"2019-11-15T07:11:42.615Z","comments":true,"path":"2019/11/15/deepcss/","link":"","permalink":"https://xmtd.github.io/2019/11/15/deepcss/","excerpt":"","text":"vue css中/deep/用法/deep/的意思大概为深入的，深远的（深度选择）。Scoped CSS规范是Web组件产生不污染其他组件，也不被其他组件污染的CSS规范。这样在打包的时候会生成一个独一无二hash值，这样父组件的样式就不会影响到子组件了；再用别人或者第三方组件是，要是想修改其组件的样式，一般都是提取公共文件，但是存在问题是有时候你修改一处就可能影响到别的地方，这个时候就可以需要一种方式，既不影响别的地方，又能修改子组件的样式。 例子中使用了scoped属性，编译之后都会加上data-v-5419d6af的hash值，此时不用/deep/的话是，el-tabs的css会生效，el-tabs底下的class就不会生效了，加上deep后就会进行深度选择，就会生效，寻找路径为下图 这类似于css module中的global属性，加上global修改第三方组件才能生效","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xmtd.github.io/tags/css/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-04T03:36:10.878Z","updated":"2019-11-04T03:36:10.879Z","comments":true,"path":"2019/11/04/hello-world/","link":"","permalink":"https://xmtd.github.io/2019/11/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server12启动$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo g -d 12清楚缓存hexo clean More info: Deployment","categories":[],"tags":[]},{"title":"lodash之concat","slug":"lodash之concat","date":"2019-10-18T03:12:35.000Z","updated":"2019-11-04T03:30:27.332Z","comments":true,"path":"2019/10/18/lodash之concat/","link":"","permalink":"https://xmtd.github.io/2019/10/18/lodash%E4%B9%8Bconcat/","excerpt":"","text":"function copyArray(source, array) { var index = -1, length = source.length; // 这里判断 array 是否为 undefined，如果是就定义一个与 source 长度相等的数组。 array || (array = Array(length)); while (++index &lt; length) { array[index] = source[index]; } return array;} // arrayPush方法是在传入的参数array基础上进行拼接的function arrayPush(array, values) { var index = -1, length = values.length, offset = array.length; while (++index &lt; length) { array[offset + index] = values[index]; } return array; /** * 举例分析： * arrayPush([1,2,3], [4, [5]]); * 刚进来 index = -1; length = 2; offset = 3; * 进入循环 * index = 0; offset + index = 3; array[3] = values[0] = 4; * index = 1; offset + index = 4; array[4] = values[1] = [5]; * index = 2; 停止循环 * * array = [1,2,3,4,[5]] * */} var isArray = Array.isArray; // 这个方法是在判断 value 是否是可以被打平的 arguments 对象或者数组。如果是，返回 true，若不是，则返回 falsefunction isFlattenable(value) { return isArray(value) || isArguments(value) || !!(spreadableSymbol &amp;&amp; value &amp;&amp; value[spreadableSymbol]);} /** * @param array @param depth @param predicate 每次迭代调用的函数 @param isStrict 限制 @param result @returns {Array} /// 减少嵌套数组function baseFlatten(array, depth, predicate, isStrict, result) { // 2, [3], [4], -1: [1] var index = -1, length = array.length; // 判断是否传入 predicate, 若没有，将方法 isFlattenable 赋值给 predicate predicate || (predicate = isFlattenable); result || (result = []); //[1,[3], [4, [5]]] while (++index &lt; length) { var value = array[index]; if (depth &gt; 0 &amp;&amp; predicate(value)) { if (depth &gt; 1) { // Recursively flatten arrays (susceptible to call stack limits). baseFlatten(value, depth - 1, predicate, isStrict, result); } else { arrayPush(result, value); } } else if (!isStrict) { result[result.length] = value; } } return result;} // 源码// _.concat(array, [values]) 创建一个新数组，将array与任何数组 或 值连接在一起/**var array = [1];var other = _.concat(array, 2, [3], [[4]]); console.log(other);// =&gt; [1, 2, 3, [4]] console.log(array);*/function concat() { // [1], 2, [3], [4] // 获取参数个数 var length = arguments.length; if (!length) { return []; } var args = Array(length - 1), // 去除0索引以外的参数 array = arguments[0], // 第一个元素 index = length; // 从后往前添加 while (index--) { args[index - 1] = arguments[index]; /** * 4 index = 3; args[2] = arguments[3] = [4]; * 3 index = 2; args[1] = arguments[2] = [3]; * 2 index = 1; args[0] = arguments[1] = 2; * 1 index = 0; args[-1] = arguments[0] = [1]; * args = [2, [3], [4], -1: [1]] */ } return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));}","categories":[],"tags":[{"name":"源码","slug":"源码","permalink":"https://xmtd.github.io/tags/%E6%BA%90%E7%A0%81/"}]}]}