{"meta":{"title":"Xmtd","subtitle":null,"description":null,"author":"mtd","url":"https://Xmtd.github.io","root":"/"},"pages":[{"title":"搜索","date":"2019-10-18T08:24:36.000Z","updated":"2019-10-18T06:10:19.517Z","comments":false,"path":"search/index.html","permalink":"https://xmtd.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"TypeScript 的 extends 条件类型","slug":"ts-extends-md","date":"2020-12-24T11:43:36.000Z","updated":"2021-02-08T09:58:37.237Z","comments":true,"path":"2020/12/24/ts-extends-md/","link":"","permalink":"https://xmtd.github.io/2020/12/24/ts-extends-md/","excerpt":"","text":"TypeScript 的 extends 条件类型这是 TS2.8 版本中推出的特性，此能力让类型定义变的更加灵活，需要注意：extends 运用在 type 和 class 中时完全是两种作用的效果。 条件类型是一种 条件表达式 进行类型的关系检测 分为以下几种类型检测 简单值(原始值)的匹配 123456相当于是匹配两值是否相等type Equal&lt;X, Y&gt; = X extends Y ? true : false;type Num = Equal&lt;1, 1&gt;; // truetype Str = Equal&lt;'a', 'a'&gt;; // truetype Boo = Equal&lt;true, false&gt;; // false 简单的类型匹配 123456789101112131415161718匹配是否属于某个基本类型type isStr&lt;T&gt; = T extends string ? true : false;isStr&lt;\"2\"&gt; // trueisStr&lt;2&gt; // false当然，我们也可以像写三元表达式一样进行类型匹配type TypeName&lt;T&gt; = T extends string ? \"string\" : T extends number ? \"number\" : T extends boolean ? \"boolean\" : T extends undefined ? \"undefined\" : T extends Function ? \"function\" : \"object\";type A = TypeName&lt;\"a\"&gt;; // \"string\"type B = TypeName&lt;true&gt;; // \"boolean\"type C = TypeName&lt;() =&gt; void&gt;; // \"function\"type D = TypeName&lt;string[]&gt;; // \"object\" 判断联合类型 1234567891011121314151617181920212223type A&lt;A, B&gt; = A extends B ? 'true' : 'false'; // 'true'type B = 'x';type C = 'x' | 'y';type D = A&lt;B, C&gt; // 'true'看上去没什么问题，那是因为我们传入了一个明确的判断值，肯定为 'true'。但是当传入的A是联合类型的话，返回的值则大径相庭type B = 'x' | 'y';type C = 'x' | 'y';type D = A&lt;B, C&gt; // 'true' 当两个联合一样返回是'true'type B = 'x' | 'y' | 'z';type C = 'x' | 'y';type D = A&lt;B, C&gt; // 'true' | 'false' 两个联合类型不一样时，返回的是 'true'|'false'其实是因为Ts的一个 *分布条件类型* 特性, T extends U ? X : Y，当 T 是 A|B 时候，会拆分为A extends U ? X : Y | B extends U ? X : Y。上面被转换为：'x' extends C ? 'true' : 'false' | 'y' extends C ? 'true' : 'false' | 'z' extends C ? 'true' : 'false' ==&gt; 'true' | 'true' | 'false' ==&gt; 'true' | 'false'通过这个特性，我们可以实现Exclude过滤功能的函数:type Exclude&lt;T, U&gt; = T extends U ? never : T;type Values = Exclude&lt;\"x\" | \"y\" | \"z\", \"x\"&gt;; // 'y' | 'z'","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://xmtd.github.io/tags/typescript/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-24T12:34:35.223Z","updated":"2020-02-24T12:34:35.223Z","comments":true,"path":"2020/02/24/hello-world/","link":"","permalink":"https://xmtd.github.io/2020/02/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server12启动$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo g -d https://xmtd.github.io/2020/02/24/proxy/ 12清楚缓存hexo clean More info: Deployment","categories":[],"tags":[]},{"title":"代理模式 - proxy","slug":"proxy","date":"2020-02-24T11:43:36.000Z","updated":"2020-02-24T12:31:34.837Z","comments":true,"path":"2020/02/24/proxy/","link":"","permalink":"https://xmtd.github.io/2020/02/24/proxy/","excerpt":"","text":"什么是代理模式 代理模式（英语：Proxy Pattern）是程序设计中的一种设计模式。 所谓的代理者是指一个类别可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、内存中的大对象、文件或其它昂贵或无法复制的资源。 著名的代理模式例子为引用计数（英语：reference counting）指针对象。 当一个复杂对象的多份副本须存在时，代理模式可以结合享元模式以减少内存用量。典型作法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除。 上面是维基百科中对代理模式的一个整体的定义.而在JavaScript中代理模式的具体表现形式就是ES6中的新增对象 — Proxy Proxy 介绍在MDN上对于Proxy的解释是: Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。 Proxy用于修改某些操作的默认行为，也可以理解为在目标对象之前架设一层拦截，外部所有的访问都必须先通过这层拦截，因此提供了一种机制，可以对外部的访问进行过滤和修改。这个词的原理为代理，在这里可以表示由它来“代理”某些操作，译为“代理器” Proxy的使用场景 ES6原生提供了Proxy构造函数，用来生成Proxy实例。 1let proxy = new Proxy(target, handler); Proxy对象的所有用法，都是上面的这种形式。不同的只是handle参数的写法。其中new Proxy用来生成Proxy实例，target是表示所要拦截的对象，handle是用来定制拦截行为的对象 下面是简单的Proxy例子，使用的是get代理 1234567891011121314let target = &#123; x: 10, y: 20&#125;let handler = &#123; get: (obj, prop) =&gt; 42&#125;target = new Proxy(target, handler)target.x //42target.y //42target.x // 42 结果是一个对象将为任何属性访问操作都返回“42”。 这包括target.x，target[&#39;x&#39;]，Reflect.get(target, &#39;x&#39;)等。但是，Proxy 当然不限于属性的读取。 它只是十几个不同代理中的一个： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051handler.getPrototypeOf()// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。handler.setPrototypeOf()// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。handler.isExtensible()// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。handler.preventExtensions()// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。handler.getOwnPropertyDescriptor()// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, \"foo\") 时。handler.defineProperty()// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, \"foo\", &#123;&#125;) 时。handler.has() // 以下几个是常用的// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 \"foo\" in proxy 时。handler.get()// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。handler.set()// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。handler.deleteProperty()// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。handler.ownKeys()// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。handler.apply()// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。handler.construct()// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。 具有代理的API - 复杂的示例通过使用简单用例中的知识，我们可以创建一个API包装器，以便在我们的应用程序中使用。 当前只支持 get 和 post 请求，但它可以很容易地扩展。代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const api = new Proxy(&#123;&#125;, &#123; get(target, key, context) &#123; if (target[key]) &#123; return target[key] &#125; return ['get', 'post'].reduce((acc, key) =&gt; &#123; acc[key] = (config, data) =&gt; &#123; if (!config || !config.url || config.url === '') &#123; // 没有URL throw new Error('Url cannot be empty.'); &#125; let isPost = key === 'post'; if (isPost &amp;&amp; !data) throw new Error('Please provide data in JSON format when using POST request.'); // post请求提供JSON格式的数据 config.headers = isPost ? Object.assign(config.headers || &#123;&#125;, &#123; 'content-type': 'application/json;chartset=utf8' &#125;) : config.headers; return new Promise((resolve, reject) =&gt; &#123; let xhr = new XMLHttpRequest(); xhr.open(key, config.url); if (config.headers) &#123; Object.keys(config.headers).forEach((header) =&gt; &#123; xhr.setRequestHeader(header, config.headers[header]); &#125;); &#125; xhr.onload = () =&gt; (xhr.status === 200 ? resolve : reject)(xhr); xhr.onerror = () =&gt; reject(xhr); xhr.send(isPost ? JSON.stringify(data) : null); &#125;) &#125; &#125;, target)[key] &#125;, set() &#123; // 无法为代理对象新增属性 throw new Error('API methods are readonly'); &#125;, deleteProperty() &#123; // 禁止删除属性 throw new Error('API methods cannot be deleted!'); &#125; // 使用 api.get(&#123; url: 'my-url' &#125;).then((xhr) =&gt; &#123; alert('Success'); &#125;, (xhr) =&gt; &#123; alert('Fail'); &#125;);&#125;) get 在这里很有趣，它做了几件事。target 是一个空对象，get 方法将在第一次有人使用 api 时创建所有方法(如当前的 get 和 post请求)，在 reduce 回调中，我们根据提供的配置执行API规范所需的验证和检查。在此示例中，我们不允许空URL和发布请求而不提供数据。这些检查可以扩展和修改，但重要的是我们只能在这一个地方集中处理。reduce 仅在第一次API调用时完成，之后都会跳过整个 reduce 进程，get 只会执行默认行为并返回属性值，即API处理程序。每个处理程序返回一个Promise对象，负责创建请求并调用服务 结语当您需要对数据进行更多控制时，代理可以派上用场。你可以根据受控规则扩展或拒绝对原始数据的访问，从而监视对象并确保正确行为。","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"https://xmtd.github.io/tags/es6/"}]},{"title":"简单易懂的CSS Modules","slug":"cssmodule","date":"2019-11-27T07:49:16.000Z","updated":"2019-11-27T09:22:55.894Z","comments":true,"path":"2019/11/27/cssmodule/","link":"","permalink":"https://xmtd.github.io/2019/11/27/cssmodule/","excerpt":"","text":"CSS的痛点我们都知道，css入门简单，深入就比较难，样式简单维护难，css痛点有很多 css的规则是全局的，任何一个组件的样式规则，都对真个页面有效，很容易出现全局污染（覆盖）问题 为了解决全局污染问题，那就吧class命名写长一点、加一层父级选择器、降低冲突几率，但css命名就混乱了 组件依赖管理不彻底，组件应该相互独立，引入一个组件时，应该只引入它所需要的 CSS 样式 CSS Module为了解决一上问题，就产生css module, css module会产生局部作用域，它会产生一个独一无二的class名字，不会与其他同名选择器重名 启用 css module在项目里应用CSS Modules有很多方法，目前比较常用的是使用webpack的css-loader,此处是与sass一起使用的 12345678910111213141516171819202122232425262728module: &#123; rules: [ &#123; test: /\\.scss/, exclude: /node_modules/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; modules: true, // 开启 css module &#125; &#125;, &#123; loader: 'postcss-loader' // 自动添加css前缀 &#125;, &#123; loader: 'sass-loader', options: &#123; sourceMap: true, outputStyle: &#123; expanded: true &#125; &#125; &#125; ] &#125; ] &#125; 使用css module编写 scss 12345.root &#123; .text &#123; width: 200px; &#125;&#125; 使用 jsx12345import styles from './index.scss';&lt;div className=&#123;styles.root&#125;&gt; &lt;div className=&#123;styles.text&#125;&gt;test&lt;/div&gt;&lt;/div&gt; 编译之后可以看出css module为每个class生成了唯一的class类名，它将class转换成对应的全局唯一hash值来形成局部作用域。css module默认使用的是局部作用域，就相当于给每个 class 名外加了一个 :local 这是默认的，也可以显式使用，但是当需要修改第三方组件的class时，就需要使用全局作用域来更改类 12345678910111213:local(.root) &#123; // 默认是局部作用域 :local(.text)&#123; width: 200px; &#125; :global &#123; // 修改第三方组件（antd）,使用全局作用域，但是他是相对于.root底下的全局作用域，所已完全不必担心污染其他组件 .ant-btn &#123; width: 200px; &#125; .ant-input &#123; width: 200px; &#125; &#125;&#125; 图上所知，加上global属性，就会在相对应的root底下的全局作用域找类名，那么他们在元素上用法的区别就是局部作用域需要使用js式（styls.xxx）;全局作用域的就是直接使用 jsx1234567891011121314151617.root &#123; .text &#123; width: 200px &#125; :global &#123; .text2 &#123; width: 200px &#125; &#125;&#125;import styles from './index.scss';&lt;div className=&#123;styles.root&#125;&gt; &lt;div className=&#123;styles.text&#125;&gt;test&lt;/div&gt; &lt;div className='text2'&gt;test2&lt;/div&gt; // 直接使用&lt;/div&gt; 其他vue中使用css module 结语无论是一直以来我们认真遵循的命名约定，还是这个新的CSS Modules，目的都是一样的：可维护的css代码。我觉得就CSS Modules基本还是在写css这一点来说，它还是很友好的。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xmtd.github.io/tags/css/"},{"name":"css-modules","slug":"css-modules","permalink":"https://xmtd.github.io/tags/css-modules/"}]},{"title":"http server","slug":"http-server","date":"2019-11-25T06:15:04.000Z","updated":"2019-11-25T06:28:19.768Z","comments":true,"path":"2019/11/25/http-server/","link":"","permalink":"https://xmtd.github.io/2019/11/25/http-server/","excerpt":"","text":"使用http-server快速搭建本地服务在静态页面中需要进行局域网进行访问时，可以开启这个 http-server 来进行访问 该环境是基于node环境的，所以必须先安装node.js 打开命令行模式，输入node -v如果显示了版本号，就说明已经安装完成。如果提示没有这个命令，请在node.js官网进行安装 如果完成上一步，在命令行下进行安装http-server,命令是npm install http-server -g 安装完成后，进入你需要局域网访问的目录，敲hs命令就会显示访问的端口，就可以直接进行访问","categories":[],"tags":[{"name":"server","slug":"server","permalink":"https://xmtd.github.io/tags/server/"}]},{"title":"async/await 用法整理","slug":"async-await","date":"2019-11-18T06:58:52.000Z","updated":"2019-11-18T07:28:50.136Z","comments":true,"path":"2019/11/18/async-await/","link":"","permalink":"https://xmtd.github.io/2019/11/18/async-await/","excerpt":"","text":"它最受欢迎的地方：能让异步代码写起来像同步代码，并且方便控制顺序。 async/await 概念解释 async async的用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行，async 函数返回的是一个promise 对象。 await await的含义为等待。意思就是代码需要等待await后面的函数运行完并且有了返回结果之后，才继续执行下面的代码。这正是同步的效果。 async函数是Generator函数的语法糖，并对Generator函数进行了改进。Generator函数简介 Generator 函数是一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，可以依次遍历Generator函数的每一个状态，但是只有调用next方法才能遍历到下一个状态，所以其实提供了一种暂停执行函数，yield表达式就是暂停标志。 123456789101112function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 可以看出，helloWorldGenerator函数被调用时并没有执行，而是返回了一个遍历器对象，只有调用next方法、内部指针指向该语句时才执行，每次调用next方法，就回返回一个对象包含value和done两个属性，value属性表示内部状态的值，是yield表达式后面表达式返回的值；done属性是个布尔值，表示是否遍历结束。即实现了函数可以暂停，也可恢复执行 Generator暂停恢复执行原理要懂得原理，得了解协程的概念 一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 协程是一种比线程更加轻量级的存在。普通线程是抢先式的，会争夺cpu资源，而协程是合作的，可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。它的运行流程大致如下： 协程A开始执行 协程A执行到某个阶段，进入暂停，执行权转移到协程B 协程B执行完成或暂停，将执行权交还A 协程A恢复执行 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。 执行器通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器,co 模块就是一个著名的执行器。 Generator 是一个异步操作的容器。它是需要手动执行的，它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。两种方法可以做到这一点： 1. 回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 2. Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权一个基于 Promise 对象的简单自动执行器： 123456789101112131415161718192021222324function run(gen) &#123; var g = gen(); function next(data) &#123; var result = g.next(data); if (result.done) return result.value; result.value.then(() =&gt; &#123; next(data) &#125;) &#125; next()&#125;使用：function* foo() &#123; let response1 = yield fetch('https://xxx') //返回promise对象 console.log('response1') console.log(response1) let response2 = yield fetch('https://xxx') //返回promise对象 console.log('response2') console.log(response2)&#125;run(foo); 上面代码中，只要 Generator 函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。 async的改进async彻底告别了执行器和生成器，实现更加直观简洁的代码，async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。可以说async 是Generator函数的语法糖，并对Generator函数进行了改进。 async函数对 Generator 函数的改进，体现在以下四点： 1. 内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。 2. 更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果 3. 更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。 4. 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用async/await 与 promise 相比的优势 同步代码编写方式: 用同步的思维来解决异步问题的方案。 Promise使用then函数进行链式调用，一直点点点，是一种从左向右的横向写法； async/await从上到下，顺序执行，就像写同步代码一样，更符合代码编写习惯。 多个参数传递: Promise的then函数只能传递一个参数，虽然可以通过包装成对象来传递多个参数，但是会导致传递冗余信息，比较麻烦； async/await没有这个限制，可以当做普通的局部变量来处理，用let或者const定义的块级变量想怎么用就怎么用，完全没有限制； 同步代码和异步代码可以一起编写: 使用Promise的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰； async/await整个书写习惯都是同步的，不需要纠结同步和异步的区别，当然，异步过程需要包装成一个Promise对象放在await关键字后面； 基于协程: Promise是根据函数式编程的范式，对异步过程进行了一层封装； async/await基于协程的机制，是真正的“保存上下文，控制权切换……控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述； ✨这点并不是优势也不算劣势（只能串行）: 它不能取代 Promise，尤其是我们可以很方便地用Promise.all()来实现并发，而async/await只能实现串行。 async关键字 async函数执行和普通函数一样，函数名带个()就可以了，参数个数随意，没有限制，也需要有async关键字；只是返回值是一个Promise对象，可以用then函数得到返回值，用catch抓整个流程中发生的错误； 12345678910111213141516async function testAsync() &#123; return \"hello async\";&#125;const result = testAsync(); // 返回一个Promise对象console.log(result);// async函数返回的是一个Promise对象，async函数（包括函数语句、函数表达式、Lambda表// 达式）会返回一个Promise对象，如果在函数中return一个直接量，async会把这个直接量通// 过Promise.resolve() 封装成 Promise 对象；// async函数返回的是一个Promise对象，所以在最外层不能用await获取其返回值的情况，// 应该使用原始的方式：then()链来处理这个Promise对象testAsync().then(v =&gt; &#123; console.log(v); // 输出 hello async&#125;); 表明程序里面可能有异步过程： async关键字表明程序里面可能有异步过程，里面可以有await关键字； 当然全部是同步代码也没关系，但是这样async关键字就显得多余了； 非阻塞，无等待： async函数里面如果有异步过程会等待，但是async函数本身会马上返回，不会阻塞当前线程; 可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染，async函数内部由await关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回； 在没有await的情况下执行async函数，它会立即执行，返回一个Promise对象，并且绝对不会阻塞后面的语句，这和普通返回Promise对象的函数并无二致； async函数返回类型为Promise对象： 这是和普通函数本质上不同的地方，也是使用时重点注意的地方； （1）return newPromise()；这个符合async函数本意； （2）return data；这个是同步函数的写法，这里是要特别注意的，这个时候，其实就相当于Promise.resolve(data)；还是一个Promise对象，但是在调用async函数的地方通过简单的=是拿不到这个data的，因为返回值是一个Promise对象，所以需要用.then(data =&gt; { })函数才可以拿到这个data； （3）如果没有返回值，相当于返回了Promise.resolve(undefined)； async统一catch，await不处理异步error： async函数返回的这个Promise对象的catch函数负责统一抓取内部所有异步过程的错误，await是不管异步过程的reject(error)消息的； await关键字 await只能在async函数内部使用： 不能放在普通函数里面，否则会报错； await后面也可以跟同步代码： 不过系统会自动将其转化成一个Promsie对象，比如： 1234567const a = await 'hello world'// 相当于const a = await Promise.resolve('hello world');// 跟同步代码是一样的，还不如省事点，直接去掉await关键字const a = 'hello world'; ✨await对于失败消息的处理： await只关心异步过程成功的消息resolve(data)，拿到相应的数据data，至于失败消息reject(error)，不关心不处理；对于错误的处理有以下几种方法供选择： 让await后面的Promise对象自己catch； 也可以让外面的async函数返回的Promise对象统一catch； 像同步代码一样，放在一个try…catch结构中；12345678910111213// 这是React Native的回调函数，加个async关键字，没有任何影响，但是可以用await关键字async componentDidMount() &#123; // 将异步和同步的代码放在一个try..catch中，异常都能抓到 try &#123; let array = null; let data = await asyncFunction(); // 这里用await关键字，就能拿到结果值；否则，没有await的话，只能拿到Promise对象 if (array.length &gt; 0) &#123; // 这里会抛出异常，下面的catch也能抓到 array.push(data); &#125; &#125; catch (error) &#123; alert(JSON.stringify(error)) &#125;&#125; 使用方式实践（1）像写同步代码那样，定义异步流程1234567891011121314151617181920212223242526272829303132333435363738// 异步过程封装function sleep(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('sleep for ' + ms + ' ms'); &#125;, ms); &#125;);&#125;// 定义异步流程，就像写同步代码那样async function asyncFunction() &#123; console.time('asyncFunction total executing:'); const sleep1 = await sleep(2000); console.log('sleep1: ' + sleep1); const [sleep2, sleep3, sleep4]= await Promise.all([sleep(2000), sleep(1000), sleep(1500)]); console.log('sleep2: ' + sleep2); console.log('sleep3: ' + sleep3); console.log('sleep4: ' + sleep4); const sleepRace = await Promise.race([sleep(3000), sleep(1000), sleep(1000)]); console.log('sleep race: ' + sleepRace); console.timeEnd('asyncFunction total executing:'); return 'asyncFunction done.' // 这个可以不返回，这里只是做个标记，为了显示流程&#125;// 像普通函数调用async函数，在then函数中获取整个流程的返回信息，// 在catch函数统一处理出错信息asyncFunction().then(data =&gt; &#123; // asyncFunction return 的内容在这里获取: 'asyncFunction done.' console.log(data);&#125;).catch(error =&gt; &#123; // asyncFunction 的错误统一在这里抓取 console.log(error);&#125;);// 这个代表asyncFunction函数后的代码，// 显示asyncFunction本身会立即返回，不会阻塞主线程console.log('after asyncFunction code executing....'); 123456789101112131415161718192021// 执行结果after asyncFunction code executing....sleep1: sleep for 2000 mssleep2: sleep for 2000 mssleep3: sleep for 1000 mssleep4: sleep for 1500 mssleep race: sleep for 1000 msasyncFunction total executing:: 5006.276123046875msasyncFunction done.// console输出：Promise &#123;&lt;pending&gt;&#125; __proto__: Promise [[PromiseStatus]]: \"resolved\" [[PromiseValue]]: \"asyncFunction done.\"VM12229:5 sleep1: sleep for 2000 msVM12229:7 sleep2: sleep for 2000 msVM12229:8 sleep3: sleep for 1000 msVM12229:9 sleep4: sleep for 1500 msVM12229:11 sleep race: sleep for 1000 msVM12229:12 asyncFunction total executing:: 5004.796875ms 代码分析： after asyncFunction code executing….代码位置在async函数asyncFunction()调用之后，反而先输出，这说明async函数asyncFunction()调用之后会马上返回，不会阻塞主线程； sleep1: sleep for 2000 ms这是第一个await之后的第一个异步过程，最先执行，也最先完成，说明后面的代码，不论是同步和异步，都在等他执行完毕； sleep2 ~ sleep4这是第二个await之后的Promise.all()异步过程，这是“比慢模式”，三个sleep都完成后，再运行下面的代码，耗时最长的是2000ms； sleep race: sleep for 1000 ms这是第三个await之后的Promise.race()异步过程，这是“比快模式”，耗时最短sleep都完成后，就运行下面的代码，耗时最短的是1000ms； asyncFunction total executing:: 5006.276123046875ms这是最后的统计总共运行时间代码，三个await之后的异步过程之和： 1000（独立的） + 2000（Promise.all） + 1000（Promise.race） = 5000ms 这个和统计出来的5006.276123046875ms非常接近，说明上面的异步过程，和同步代码执行过程一致，协程真的是在等待异步过程执行完毕； asyncFunction done.这个是async函数返回的信息，在执行时的then函数中获得，说明整个流程完毕之后参数传递的过程； （2）顺序执行，结果作为下一次输入123456789101112131415161718192021222324/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125; 123456789101112131415161718192021// Promise方式调用function doIt() &#123; console.time(\"doIt\"); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\"); &#125;);&#125;doIt();// c:\\var\\test&gt;node --harmony_async_await .// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms 123456789101112// async/await方式调用async function doIt() &#123; console.time(\"doIt\"); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\");&#125;doIt(); （3）中间参数需要保留123456789101112131415161718192021222324/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(m, n) &#123; console.log(`step2 with $&#123;m&#125; and $&#123;n&#125;`); return takeLongTime(m + n);&#125;function step3(k, m, n) &#123; console.log(`step3 with $&#123;k&#125;, $&#123;m&#125; and $&#123;n&#125;`); return takeLongTime(k + m + n);&#125; 1234567891011121314151617181920212223242526// Promise方式调用function doIt() &#123; console.time(\"doIt\"); const time1 = 300; step1(time1) .then(time2 =&gt; &#123; return step2(time1, time2) .then(time3 =&gt; [time1, time2, time3]); &#125;) .then(times =&gt; &#123; const [time1, time2, time3] = times; return step3(time1, time2, time3); &#125;) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\"); &#125;);&#125;doIt();// step1 with 300// step2 with 300 and 500// step3 with 300, 500 and 1000// result is 2000// doIt: 2913.488037109375ms 注意：这里为什么不能直接这样写promise式调用，因为中间参数 time2、time3都没有办法保存 12345678910111213function doIt() &#123; console.time(\"doIt\"); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time1, time2)) .then(time3 =&gt; step3(time1, time2, time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\"); &#125;);&#125;doIt(); 123456789101112131415161718// async/await方式调用async function doIt() &#123; console.time(\"doIt\"); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time1, time2); const result = await step3(time1, time2, time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(\"doIt\");&#125;doIt();// step1 with 300// step2 with 300 and 500// step3 with 300, 500 and 1000// result is 2000// doIt: 2913.488037109375ms 关于协程 关于协程 进程&gt;线程&gt;协程 协程的第一大优势是具有极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显； 协程的第二大优势是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多； 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行，需要注意的是：在一个子程序中中断，去执行其他子程序，这并不是函数调用，有点类似于CPU的中断； 用汽车和公路举个例子：js公路只是单行道（主线程），但是有很多车道（辅助线程）都可以汇入车流（异步任务完成后回调进入主线程的任务队列）；generator把js公路变成了多车道（协程实现），但是同一时间只有一个车道上的车能开（依然单线程），不过可以自由变道（移交控制权）； 协程意思是多个线程互相协作，完成异步任务，运行流程大致如下： 1）协程A开始执行； 2）协程A执行到一半，进入暂停，执行权转移到协程B； 3）一段时间后，协程B交还执行权； 4）协程A恢复执行； 协程是一个无优先级的子程序调度组件，允许子程序在特定的地点挂起恢复； 线程包含于进程，协程包含于线程，只要内存足够，一个线程中可以有任意多个协程，但某一个时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源； 就实际使用理解来说，协程允许我们写同步代码的逻辑，却做着异步的事，避免了回调嵌套，使得代码逻辑清晰； 何时挂起，唤醒协程：协程是为了使用异步的优势，异步操作是为了避免IO操作阻塞线程，那么协程挂起的时刻应该是当前协程发起异步操作的时候，而唤醒应该在其他协程退出，并且他的异步操作完成时； 单线程内开启协程，一旦遇到io，从应用程序级别（而非操作系统）控制切换对比操作系统控制线程的切换，用户在单线程内控制协程的切换，优点如下：1）协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级；2）单线程内就可以实现并发的效果，最大限度地利用cpu； 12345678910111213141516171819202122232425262728// 传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。// 如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：import timedef consumer(): r = '' while True: n = yield r if not n: return print('[CONSUMER] Consuming %s...' % n) time.sleep(1) r = '200 OK'def produce(c): c.next() n = 0 while n &lt; 5: n = n + 1 print('[PRODUCER] Producing %s...' % n) r = c.send(n) print('[PRODUCER] Consumer return: %s' % r) c.close()if __name__=='__main__': c = consumer() produce(c) 123456789101112131415[PRODUCER] Producing 1...[CONSUMER] Consuming 1...[PRODUCER] Consumer return: 200 OK[PRODUCER] Producing 2...[CONSUMER] Consuming 2...[PRODUCER] Consumer return: 200 OK[PRODUCER] Producing 3...[CONSUMER] Consuming 3...[PRODUCER] Consumer return: 200 OK[PRODUCER] Producing 4...[CONSUMER] Consuming 4...[PRODUCER] Consumer return: 200 OK[PRODUCER] Producing 5...[CONSUMER] Consuming 5...[PRODUCER] Consumer return: 200 OK 注意到consumer函数是一个generator（生成器），把一个consumer传入produce后： 首先调用c.next()启动生成器； 然后，一旦生产了东西，通过c.send(n)切换到consumer执行； consumer通过yield拿到消息，处理，又通过yield把结果传回； produce拿到consumer处理的结果，继续生产下一条消息； produce决定不生产了，通过c.close()关闭consumer，整个过程结束。 整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。 参考链接：async/await的基础用法","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://xmtd.github.io/tags/ES6/"},{"name":"异步","slug":"异步","permalink":"https://xmtd.github.io/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"vue css中/deep/深度选择","slug":"deepcss","date":"2019-11-15T06:41:29.000Z","updated":"2019-11-22T08:36:57.315Z","comments":true,"path":"2019/11/15/deepcss/","link":"","permalink":"https://xmtd.github.io/2019/11/15/deepcss/","excerpt":"","text":"vue css中/deep/用法/deep/的意思大概为深入的，深远的（深度选择）。Scoped CSS规范是Web组件产生不污染其他组件，也不被其他组件污染的CSS规范。这样在打包的时候会生成一个独一无二hash值，这样父组件的样式就不会影响到子组件了；再用别人或者第三方组件是，要是想修改其组件的样式，一般都是提取公共文件，但是存在问题是有时候你修改一处就可能影响到别的地方，这个时候就可以需要一种方式，既不影响别的地方，又能修改子组件的样式。 加入scoped属性 可以看出，scoped属性会将 template 中的每个元素加入 [data-v-xxxx]的hash值，但如果引用了第三方组件，默认只会对组件的最外层（div）加入这个 [data-v-xxxx] 属性，但第二层开始就没有效果了，如上图所示，第一层el-tabs加上了[data-v-xxxx]，底下的el-tabs__header就没有了 这个时候修改样式，未加/deep/ 编译后的css可以看出，寻找的路径为.m-transaction-details-wrapper .el-tabs .el-tabs__header[data-v-5419d6af]但是在看html元素上，并没有在.el-tabs__header加入[data-v-5419d6af]，所以导致不生效 加上/deep/ 此时编译后的css寻找路径为.m-transaction-details-wrapper[data-v-5419d6af] .el-tabs .el-tabs__header,就可以生效了，这类似于css module中的global属性，加上global修改第三方组件才能生效","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://xmtd.github.io/tags/css/"},{"name":"vue","slug":"vue","permalink":"https://xmtd.github.io/tags/vue/"}]},{"title":"lodash之concat","slug":"lodash之concat","date":"2019-10-18T03:12:35.000Z","updated":"2019-11-04T03:30:27.332Z","comments":true,"path":"2019/10/18/lodash之concat/","link":"","permalink":"https://xmtd.github.io/2019/10/18/lodash%E4%B9%8Bconcat/","excerpt":"","text":"function copyArray(source, array) { var index = -1, length = source.length; // 这里判断 array 是否为 undefined，如果是就定义一个与 source 长度相等的数组。 array || (array = Array(length)); while (++index &lt; length) { array[index] = source[index]; } return array;} // arrayPush方法是在传入的参数array基础上进行拼接的function arrayPush(array, values) { var index = -1, length = values.length, offset = array.length; while (++index &lt; length) { array[offset + index] = values[index]; } return array; /** * 举例分析： * arrayPush([1,2,3], [4, [5]]); * 刚进来 index = -1; length = 2; offset = 3; * 进入循环 * index = 0; offset + index = 3; array[3] = values[0] = 4; * index = 1; offset + index = 4; array[4] = values[1] = [5]; * index = 2; 停止循环 * * array = [1,2,3,4,[5]] * */} var isArray = Array.isArray; // 这个方法是在判断 value 是否是可以被打平的 arguments 对象或者数组。如果是，返回 true，若不是，则返回 falsefunction isFlattenable(value) { return isArray(value) || isArguments(value) || !!(spreadableSymbol &amp;&amp; value &amp;&amp; value[spreadableSymbol]);} /** * @param array @param depth @param predicate 每次迭代调用的函数 @param isStrict 限制 @param result @returns {Array} /// 减少嵌套数组function baseFlatten(array, depth, predicate, isStrict, result) { // 2, [3], [4], -1: [1] var index = -1, length = array.length; // 判断是否传入 predicate, 若没有，将方法 isFlattenable 赋值给 predicate predicate || (predicate = isFlattenable); result || (result = []); //[1,[3], [4, [5]]] while (++index &lt; length) { var value = array[index]; if (depth &gt; 0 &amp;&amp; predicate(value)) { if (depth &gt; 1) { // Recursively flatten arrays (susceptible to call stack limits). baseFlatten(value, depth - 1, predicate, isStrict, result); } else { arrayPush(result, value); } } else if (!isStrict) { result[result.length] = value; } } return result;} // 源码// _.concat(array, [values]) 创建一个新数组，将array与任何数组 或 值连接在一起/**var array = [1];var other = _.concat(array, 2, [3], [[4]]); console.log(other);// =&gt; [1, 2, 3, [4]] console.log(array);*/function concat() { // [1], 2, [3], [4] // 获取参数个数 var length = arguments.length; if (!length) { return []; } var args = Array(length - 1), // 去除0索引以外的参数 array = arguments[0], // 第一个元素 index = length; // 从后往前添加 while (index--) { args[index - 1] = arguments[index]; /** * 4 index = 3; args[2] = arguments[3] = [4]; * 3 index = 2; args[1] = arguments[2] = [3]; * 2 index = 1; args[0] = arguments[1] = 2; * 1 index = 0; args[-1] = arguments[0] = [1]; * args = [2, [3], [4], -1: [1]] */ } return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));}","categories":[],"tags":[{"name":"源码","slug":"源码","permalink":"https://xmtd.github.io/tags/%E6%BA%90%E7%A0%81/"}]}]}